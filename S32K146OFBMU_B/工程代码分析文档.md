# S32K146OFBMU_B 电池管理系统工程代码分析文档

## 目录
1. [工程概述](#工程概述)
2. [系统架构](#系统架构)
3. [RTOS运行机制](#rtos运行机制)
4. [核心模块分析](#核心模块分析)
5. [SOC算法详解](#soc算法详解)
6. [SOH算法详解](#soh算法详解)
7. [系统运行流程](#系统运行流程)
8. [关键接口说明](#关键接口说明)

---

## 工程概述

### 项目信息
- **项目名称**: S32K146OFBMU_B
- **处理器**: NXP S32K146
- **RTOS**: FreeRTOS
- **功能**: 电池管理系统(BMS - Battery Management System)
- **开发公司**: 深圳英飞源科技有限公司

### 主要功能
- 电池组电压、电流、温度监测
- SOC(State of Charge)状态估算
- SOH(State of Health)健康度评估
- SOE(State of Energy)能量状态计算
- 电池保护与故障诊断
- CAN/Modbus通信
- 均衡控制
- 绝缘检测
- 数据记录与统计

---

## 系统架构

### 目录结构

```
S32K146OFBMU_B/
├── Sources/                    # 源代码目录
│   ├── main.c                 # 主程序入口
│   ├── OSUser/                # RTOS用户层
│   │   └── OSUserHOOK.c       # RTOS任务钩子函数
│   ├── BSPSys/                # BSP系统层
│   │   ├── Driver/            # 硬件驱动层
│   │   └── Util/              # 工具函数
│   ├── Funtion/               # 功能模块
│   │   ├── SocLib/            # SOC/SOE算法库
│   │   ├── EnergyCalc/        # 能量计算模块
│   │   ├── Measurement/       # 测量采样模块
│   │   ├── Diagnosis/         # 故障诊断模块
│   │   ├── DataCalc/          # 数据计算模块
│   │   ├── CanLib/            # CAN通信库
│   │   ├── ModbusLib/         # Modbus通信库
│   │   ├── Parameter/        # 参数管理模块
│   │   ├── Statistics/       # 统计模块
│   │   ├── Recording/         # 记录模块
│   │   └── PowerManag/        # 电源管理模块
│   ├── Logics/                # 逻辑控制层
│   │   ├── Tactics/           # 策略控制
│   │   ├── Balance/           # 均衡控制
│   │   ├── FstChg/            # 快充策略
│   │   ├── CanUser/           # CAN用户层
│   │   └── EventUser/         # 事件处理
│   └── SaftyCheck/            # 安全检测模块
│       └── SafetyLib/      # 安全库
├── SDK/                       # SDK库文件
├── Generated_Code/            # 自动生成代码
└── Project_Settings/          # 项目配置

```

### 系统分层架构

```
┌─────────────────────────────────────┐
│        应用层 (Application)          │
│  (策略控制、均衡、快充、事件处理)      │
├─────────────────────────────────────┤
│        功能层 (Function)             │
│  (SOC/SOH算法、测量、诊断、通信)      │
├─────────────────────────────────────┤
│        BSP层 (Board Support)         │
│  (驱动、硬件抽象、中断处理)            │
├─────────────────────────────────────┤
│        RTOS层 (FreeRTOS)            │
│  (任务调度、定时器、队列、信号量)      │
├─────────────────────────────────────┤
│        硬件层 (Hardware)             │
│  (S32K146 MCU、外设)                 │
└─────────────────────────────────────┘
```

---

## RTOS运行机制

### FreeRTOS配置

系统使用FreeRTOS作为实时操作系统，主要配置如下：

- **时钟频率**: 80MHz (configCPU_CLOCK_HZ)
- **Tick频率**: 1000Hz (configTICK_RATE_HZ = 1ms)
- **最大优先级**: 8级
- **调度方式**: 抢占式调度 (configUSE_PREEMPTION = 1)
- **时间片**: 启用 (configUSE_TIME_SLICING = 1)

### 任务创建与调度

#### 1. 软件定时器任务

系统创建了10个周期性软件定时器，用于执行不同周期的任务：

| 定时器 | 周期 | 主要功能 |
|--------|------|----------|
| Timer5ms | 5ms | CAN通信包发送、SBC诊断、CATL协议 |
| Timer10ms | 10ms | 电流限值计算、电压温度计算、故障诊断、电能量计算、均衡控制、绝缘检测 |
| Timer50ms | 50ms | 故障滤波检测、SOC/SOE算法包总任务、远程升级 |
| Timer100ms | 100ms | 电池组工作状态检测、充放电状态检测、安全等级诊断、保护控制 |
| Timer200ms | 200ms | 热管理控制、电压限值计算、工作模式检测、通信诊断、校准 |
| Timer300ms | 300ms | 单次循环充放电量统计、在线升级 |
| Timer400ms | 400ms | 累计充放电量统计、累计充放电能统计 |
| Timer500ms | 500ms | 外围故障检测、快充策略、历史记录处理 |
| Timer1000ms | 1000ms | 外围输出口控制、充放电次数统计、DOD统计 |
| Timer2000ms | 2000ms | 系统下电保护、故障告警统计、系统时间记录 |

#### 2. 独立任务

系统创建了6个独立的任务，用于处理实时性要求高的操作：

| 任务名称 | 优先级 | 功能描述 |
|---------|--------|----------|
| HigInfoSampleTask | RTOS_ID_HV_SAMP | 高压信息采样任务 |
| CellInfoSampleTask | RTOS_ID_CELL_SAMP | 电池信息采样任务 |
| LowInfoSampleTask | RTOS_ID_LV_SAMP | 低压信息采样任务 |
| BSPCANSendTask | RTOS_ID_CAN_SEND | CAN信息发送任务 |
| BSPCANRcvTask | RTOS_ID_CAN_RCV | CAN信息接收任务 |
| BSPUARTRcvTask | RTOS_ID_UART_RCV | UART信息接收任务 |

### 任务调度流程

```
main()
  ├── BSPUserCfgInit()          # BSP配置初始化
  ├── BSPDriverInit()            # BSP驱动初始化
  ├── BSPDisIRQUserInit()       # 中断初始化(禁用中断)
  ├── BSPEnIRQUserInit()        # 中断初始化(使能中断)
  └── RtosTaskStart()           # RTOS任务启动
      ├── 创建10个软件定时器
      ├── 创建6个独立任务
      └── vTaskStartScheduler()  # 启动任务调度器
```

### 任务执行时序

```
时间轴:
0ms    5ms    10ms   50ms   100ms  200ms  300ms  400ms  500ms  1000ms 2000ms
│      │      │      │      │      │      │      │      │      │      │
├─5ms──┼─10ms─┼─50ms─┼─100ms┼─200ms┼─300ms┼─400ms┼─500ms┼─1000ms┼─2000ms─┤
│      │      │      │      │      │      │      │      │      │      │
定时器  定时器  定时器  定时器  定时器  定时器  定时器  定时器  定时器  定时器
任务    任务    任务    任务    任务    任务    任务    任务    任务    任务

独立任务(持续运行):
- 采样任务(高压/电池/低压)
- CAN发送/接收任务
- UART接收任务
```

---

## 核心模块分析

### 1. 测量采样模块 (Measurement)

#### 1.1 电池信息采样 (CellAFESamp.c)
- **功能**: 采集单体电池电压、温度
- **采样频率**: 独立任务实时采样
- **处理**: 滤波、校准、异常检测

#### 1.2 高压采样 (HigAFESamp.c)
- **功能**: 采集电池组总电压、预充电压
- **采样频率**: 独立任务实时采样
- **处理**: 高压校准、异常检测

#### 1.3 电流采样 (CurrSample.c)
- **功能**: 采集充放电电流
- **采样频率**: 独立任务实时采样
- **处理**: 电流积分、方向判断

#### 1.4 绝缘检测 (InsuCheck.c)
- **功能**: 检测电池组对地绝缘电阻
- **检测周期**: 10ms任务中调用
- **算法**: 通过注入信号测量绝缘值
- **保护**: 绝缘值过低时触发保护

### 2. 数据计算模块 (DataCalc)

#### 2.1 电流限值计算 (CurrLimCalc.c)
- **功能**: 根据电压、温度、SOC计算充放电电流限值
- **算法**: PID控制、限值衰减
- **周期**: 10ms

#### 2.2 电压限值计算 (VoltLimCalc.c)
- **功能**: 计算充放电电压限值
- **周期**: 200ms

#### 2.3 特征计算 (CharactCalc.c)
- **功能**: 计算电压、温度特征值
- **周期**: 10ms

### 3. 故障诊断模块 (Diagnosis)

#### 3.1 故障检测 (DiagCheck.c)
- **功能**: 检测各类故障
- **类型**: 电压异常、温度异常、电流异常、通信异常等
- **周期**: 10ms/100ms/500ms

#### 3.2 故障滤波 (DiagFilter.c)
- **功能**: 对故障进行滤波，避免误报
- **算法**: 时间滤波、计数滤波

#### 3.3 故障生成 (DiagMaker.c)
- **功能**: 根据检测结果生成故障码
- **等级**: A级(警告)、B级(故障)

#### 3.4 安全等级 (DiagSos.c)
- **功能**: 计算系统安全等级(SOS)
- **等级**: 0-4级，级别越高越危险

### 4. 通信模块

#### 4.1 CAN通信 (CanLib/)
- **功能**: CAN总线通信
- **协议**: 自定义协议、CATL协议
- **任务**: 独立发送/接收任务

#### 4.2 Modbus通信 (ModbusLib/)
- **功能**: Modbus RTU/TCP通信
- **应用**: 上位机通信、参数配置

### 5. 参数管理模块 (Parameter)

#### 5.1 参数存储
- **存储位置**: EEPROM、内部Flash、外部Flash
- **参数类型**: 通用参数、高级参数、只读参数

#### 5.2 参数读写
- **接口**: ParaRead、ParaWrite
- **保护**: 参数校验、备份恢复

### 6. 记录统计模块

#### 6.1 数据记录 (Recording/)
- **功能**: 记录故障波形、历史数据
- **存储**: 外部Flash

#### 6.2 统计分析 (Statistics/)
- **功能**: 充放电次数、能量统计、DOD统计
- **周期**: 300ms/400ms/1000ms

---

## SOC算法详解

### SOC (State of Charge) 状态估算

SOC表示电池的剩余容量百分比，是BMS的核心算法之一。

### 1. SOC计算架构

```
SOC算法包 (SocLib/)
├── CapInfoCalc.c          # 容量信息计算
├── SocSoeCorr.c           # SOC/SOE修正
├── SocSoeSync.c           # SOC/SOE同步
└── SocUserAPI.c           # SOC用户接口
```

### 2. 核心计算方法

#### 2.1 安时积分法 (Coulomb Counting)

**原理**: 通过积分电流计算容量变化

```c
// 当前容量计算
sCapForm.nowCap = sCapForm.nowCap + ΔQ
// ΔQ = I × Δt (电流积分)

// SOC计算
SOC = (nowCap - baseCap) / (topCap - baseCap) × 100%
```

**位置**: `CapInfoCalc.c` - `CalcGroupNowCapHandle()`

**特点**:
- 实时性好
- 需要初始SOC
- 存在累积误差

#### 2.2 温度修正

**原理**: 温度影响电池可用容量

```c
// 温度修正后的可用容量
nowCap = remainCap × tempCapPercent / 1000

// 温度修正后的SOC
soc = nowCap × 1000 / totalCap
```

**位置**: `SocSoeCorr.c` - `SocSoeTempCorrDeal()`

**温度表**: `cTempCapPercent[]` - 不同温度下的容量百分比

#### 2.3 电压末端修正

**原理**: 充放电末端根据电压进行SOC修正

**充电末端修正**:
```c
// 当电压达到充电截止电压附近时
if (cellMaxVolt >= startVolt && cellMaxVolt < finVolt) {
    // 使用线性插值: SOC = K × (voltage - startVolt) + B
    voltStepSoc = socVoltCorrK * (cellMaxVolt - startVolt) / 1000 + socVoltCorrB;
}
```

**放电末端修正**:
```c
// 当电压达到放电截止电压附近时
if (cellMinVolt <= startVolt && cellMinVolt > finVolt) {
    // 使用线性插值: SOC = B - K × (startVolt - voltage)
    voltStepSoc = socVoltCorrB - (socVoltCorrK * (startVolt - cellMinVolt) / 1000);
}
```

**位置**: `SocSoeCorr.c` - `SocSoeVStepCorrDeal()`

### 3. SOC修正策略

#### 3.1 多源融合修正

系统采用多源融合的方式修正SOC：

```c
// 1. 温度修正SOC
sTCapCorrSoc = 温度修正后的SOC

// 2. 电压末端修正SOC
sVStepCorrSoc = 电压修正后的SOC

// 3. 当前SOC
nowSoc = 安时积分计算的SOC

// 4. 融合策略
if (温度修正SOC与电压修正SOC误差 <= 3%) {
    calcSoc = (温度修正SOC + 电压修正SOC) / 2;
} else if (温度修正SOC与当前SOC误差 <= 3%) {
    calcSoc = (温度修正SOC + 当前SOC) / 2;
} else if (电压修正SOC与当前SOC误差 <= 3%) {
    calcSoc = (电压修正SOC + 当前SOC) / 2;
} else {
    calcSoc = (温度修正SOC + 电压修正SOC + 当前SOC) / 3;
}

// 5. 执行修正(修正量 >= 0.5%才修正)
if (ABS(calcSoc, nowSoc) >= 5) {
    CorrGNowCapBySocAPI(calcSoc);
}
```

**位置**: `SocSoeCorr.c` - `SocSoeAllCorrTask()`

### 4. SOC平滑显示

**原理**: 避免SOC跳变，平滑过渡到目标值

```c
// 根据目标SOC与当前显示SOC的差值，计算步进值
if (aimSoc >= 97.5%) {
    stepSoc = (aimSoc - copySoc) / 50;  // 5s内到达目标值
} else if (aimSoc >= 95%) {
    stepSoc = (aimSoc - copySoc) / 150; // 15s内到达目标值
} else if (aimSoc >= 93%) {
    stepSoc = (aimSoc - copySoc) / 200; // 20s内到达目标值
} else if (aimSoc >= 90%) {
    stepSoc = (aimSoc - copySoc) / 300; // 30s内到达目标值
}

copySoc += stepSoc;  // 平滑更新显示SOC
```

**位置**: `SocDisplay.c` - `CalcSocSlowChang()`

### 5. SOC算法执行流程

```
50ms周期任务 (SocSoeLibAllTask)
├── 1s周期: 总容量总能量自动标定
├── 500ms周期: SOC/SOE扩展卡尔曼算法(预留)
├── 500ms周期: SOC/SOE相互同步
├── 500ms周期: SOC/SOE组间同步
└── 500ms周期: SOC/SOE修正总任务
    ├── 温度修正处理
    ├── 电压末端修正处理
    └── 多源融合修正
```

### 6. 总容量自动标定

**原理**: 通过完整的充放电循环自动标定总容量

**充电标定**:
```c
// 记录低压点到高压点的充电容量
chgCap = (高压点充电容量 - 低压点充电容量) × 充放电比
dhgCap = (高压点放电容量 - 低压点放电容量)

// 计算实际充电容量
calcCap = (chgCap - dhgCap) × 1000

// 电流温度修正
calcCap = CalcTotalCapEnerByCTCorr(0, calcCap, finCurr, finTemp)

// 修正总容量(误差校验)
if (calcCap与历史值误差 <= 20%) {
    totalCap = (calcCap + 历史值) / 2;
}
```

**放电标定**:
```c
// 记录高压点到低压点的放电容量
dhgCap = (低压点放电容量 - 高压点放电容量)
chgCap = (低压点充电容量 - 高压点充电容量) × 充放电比

// 计算实际放电容量
calcCap = (dhgCap - chgCap) × 1000

// 电流温度修正后修正总容量
```

**位置**: `CapEnerCorr.c` - `TotalCapEnerCorrTask()`

---

## SOH算法详解

### SOH (State of Health) 健康度评估

SOH表示电池的健康状态，反映电池的衰减程度。

### 1. SOH计算架构

```
SOH算法 (EnergyCalc/)
├── CellFadeCalc.c         # 电池衰减计算
└── SohDisplay.c           # SOH显示
```

### 2. SOH计算方法

#### 2.1 容量法计算SOH

**原理**: 通过实际总容量与额定容量的比值计算

```c
// 容量法SOH
if (ratedCap > 0) {
    capSoh = (totalCap × 10) / ratedCap;  // 单位: 0.1%
    
    if (capSoh > 1000) {
        capSoh = 1000;  // 限制最大100%
    }
}
```

**位置**: `CellFadeCalc.c` - `CalcGroupCellFadeHandle()`

#### 2.2 循环次数法计算SOH

**原理**: 通过充放电循环次数计算衰减

```c
// 循环次数法SOH
if (ratedCycle > 0 && ratedCycle >= fadeCycle) {
    // SOH = 100% - (实际循环次数 / 额定循环次数) × 20%
    timSoh = 1000 - (fadeCycle × 200 / ratedCycle);
} else {
    timSoh = 800;  // 默认80%
}
```

**位置**: `CellFadeCalc.c` - `CalcGroupCellFadeHandle()`

### 3. SOH融合策略

系统采用容量法和循环次数法融合计算SOH：

```c
// 1. 计算两种方法的SOH
capSoh = 容量法计算的SOH
timSoh = 循环次数法计算的SOH

// 2. 判断两种方法的一致性
if (ABS(capSoh, timSoh) <= 50) {  // 误差 <= 5%
    // 误差小，以循环次数法为准(防止跳变)
    capSoh = timSoh;
    fadeCap = ratedCap × capSoh / 1000;
} else {
    // 误差大，取平均值
    capSoh = (capSoh + timSoh) / 2;
    
    // SOH不能增大
    if (capSoh > currentSoh) {
        capSoh = currentSoh;
    }
    // SOH每次最大下降0.5%
    else if (ABS(capSoh, currentSoh) > 5) {
        capSoh = currentSoh - 5;
    }
    
    // 反算衰减容量
    fadeCap = ratedCap × capSoh / 1000;
}

// 3. 更新SOH
if (capSoh != currentSoh) {
    EnerChangEepGNowCapSohHook(capSoh);  // 保存到EEPROM
}
```

**位置**: `CellFadeCalc.c` - `CalcGroupCellFadeHandle()`

### 4. SOH计算触发条件

SOH在以下情况重新计算：
- 充放电循环次数变化
- 总容量被修正

**周期**: 100ms任务中调用 `GroupFadeSohCalcTask()`

### 5. SOH显示

SOH直接显示计算值，无需平滑处理：

```c
// 获取当前SOH
soh = GetGRealSohMilliAPI();  // 单位: 0.1%

// 更新显示值
gGSysCapInfo_61[eSysCapInfo61_SOH] = soh;
```

**位置**: `SohDisplay.c` - `GroupSohDisplayTask()`

---

## 系统运行流程

### 1. 系统启动流程

```
系统上电
  ├── 硬件初始化
  │   ├── 时钟配置
  │   ├── GPIO配置
  │   └── 外设初始化
  ├── BSP初始化
  │   ├── BSPUserCfgInit()      # BSP配置
  │   ├── BSPDriverInit()       # 驱动初始化
  │   ├── BSPDisIRQUserInit()   # 中断初始化(禁用)
  │   └── BSPEnIRQUserInit()    # 中断初始化(使能)
  ├── RTOS启动
  │   ├── 创建软件定时器
  │   ├── 创建独立任务
  │   └── vTaskStartScheduler() # 启动调度器
  └── 系统运行
      ├── 采样任务持续运行
      ├── 定时器任务周期性执行
      └── 通信任务处理数据交互
```

### 2. 数据采集流程

```
硬件采样
  ├── 电池信息采样任务
  │   ├── 单体电压采样
  │   ├── 温度采样
  │   └── 数据滤波处理
  ├── 高压采样任务
  │   ├── 总电压采样
  │   ├── 预充电压采样
  │   └── 数据校准
  └── 低压采样任务
      ├── 辅助电压采样
      └── 数据校准

数据处理
  ├── 电流积分计算
  ├── 特征值计算
  └── 异常检测
```

### 3. SOC/SOH计算流程

```
10ms任务
  ├── 电流积分
  │   └── 更新当前容量
  ├── 特征值计算
  │   ├── 电压特征
  │   └── 温度特征
  └── 电能量计算
      ├── SOC计算
      └── SOE计算

50ms任务
  └── SOC/SOE算法包
      ├── 总容量标定
      ├── SOC/SOE同步
      └── SOC/SOE修正

100ms任务
  └── SOH计算
      ├── 容量法SOH
      ├── 循环次数法SOH
      └── SOH融合
```

### 4. 保护控制流程

```
10ms任务
  ├── 故障诊断
  │   ├── 电压异常检测
  │   ├── 温度异常检测
  │   └── 电流异常检测
  └── 均衡控制
      └── 电压均衡策略

100ms任务
  ├── 工作状态检测
  ├── 充放电状态检测
  ├── 安全等级诊断
  └── 保护控制
      ├── 故障保护
      └── 接触器控制

200ms任务
  └── 电压限值计算
```

### 5. 通信流程

```
CAN通信
  ├── 发送任务
  │   ├── 周期发送
  │   └── 事件发送
  └── 接收任务
      ├── 消息解析
      └── 命令处理

Modbus通信
  ├── 服务器模式
  │   ├── 参数读写
  │   └── 数据查询
  └── 客户端模式
      └── 主动上报
```

---

## 关键接口说明

### 1. SOC相关接口

```c
// 获取当前SOC (单位: 0.1%)
u16 GetGRealSocMilliAPI(void);

// 获取显示SOC (单位: 0.1%)
u16 GetGBattSocAPI(void);

// 根据SOC修正当前容量
void CorrGNowCapBySocAPI(u16 soc);

// 根据SOC修正剩余容量
void CorrGRemainCapBySocAPI(u16 soc);

// 修正总容量
void CorrGroupTotalCapAPI(u32 cap);
```

### 2. SOH相关接口

```c
// 获取当前SOH (单位: 0.1%)
u16 GetGRealSohMilliAPI(void);

// 获取衰减后的总容量
u16 GetGFadeTotalCapAPI(void);

// 获取额定容量
u16 GetGroupRatedCapAPI(void);

// 获取实际循环次数
u16 GetGroupFadeCycleAPI(void);
```

### 3. SOE相关接口

```c
// 获取当前SOE (单位: 0.1%)
u16 GetGRealSoeMilliAPI(void);

// 获取显示SOE (单位: 0.1%)
u16 GetGBattSoeAPI(void);

// 根据SOE修正当前能量
void CorrGNowEnerBySoeAPI(u16 soe);
```

### 4. 电池信息接口

```c
// 获取电池组总电压 (单位: 0.1V)
u16 GetGSampSumVoltAPI(void);

// 获取输出电流 (单位: 0.1A)
s16 GetGSampOutCurrAPI(void);

// 获取单体最大电压 (单位: 1mV)
u16 GetGCellMaxVoltAPI(void);

// 获取单体最小电压 (单位: 1mV)
u16 GetGCellMinVoltAPI(void);

// 获取平均温度 (单位: 1℃)
s8 GetGCellAvgTempAPI(void);

// 获取充放电状态
u16 GetGChgDhgStateAPI(void);  // eCURR_CHG/eCURR_DHG/eCURR_IDLE
```

### 5. 保护控制接口

```c
// 获取工作状态
u16 GetGWorkStateAPI(void);

// 获取工作模式
u16 GetGWorkModeAPI(void);

// 获取安全等级
u16 GetGSosLevelAPI(void);

// 设置故障状态
void DiagSetErrNowStateAPI(u16 errId, u16 errLevel);
```

---

## 总结

### 系统特点

1. **实时性**: 采用FreeRTOS多任务架构，关键任务5-10ms周期执行
2. **可靠性**: 多重故障检测与保护机制
3. **精确性**: SOC/SOH算法采用多源融合，提高估算精度
4. **可扩展性**: 模块化设计，便于功能扩展
5. **安全性**: 完善的故障诊断与安全保护

### 关键技术

1. **SOC算法**: 安时积分 + 温度修正 + 电压末端修正 + 多源融合
2. **SOH算法**: 容量法 + 循环次数法融合
3. **总容量标定**: 自动标定，电流温度修正
4. **故障诊断**: 多级滤波，分级保护
5. **均衡控制**: 主动均衡策略

### 应用场景

- 电动汽车电池管理系统
- 储能系统电池管理
- 工业电池组管理
- 其他需要精确电池管理的应用

---

**文档版本**: v1.0  
**最后更新**: 2024年  
**作者**: AI Assistant  
**审核**: 待审核
