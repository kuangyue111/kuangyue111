#include "main.h"
#include "Uart6_new.h"
#include "EtherNet.h"
#include "can_ring.h"

NOINIT UINT8 ViewCostBuf[64];
NOINIT UINT8 ViewMin,ViewHour,ViewSec;
time_t now;
time_t now2;


enum DISP_SIG_RATIO_def
{
	DISP_RATIO_NORMAL = 0,  //*1
	DISP_RATIO_X10,			//*10
	DISP_RATIO_X100,		//*100
	DISP_RATIO_X1000,		//*1000
	DISP_RATIO_X10000,		//*10000
};

#define	SIGTYPE_RESERVE		0

typedef struct DispSigMap_
{
	unsigned long	u32DispSigAddr;		//屏信号地址
	unsigned char	u8Ratio;			//比例关系
	unsigned char	u8Etype;			//设备类型
	unsigned char	u8SigType;			//
	unsigned short	u16Idx;				//信号在主机中的地址序号	
	
}DispSigMap_Def;

const DispSigMap_Def s_DispSigMap[] =
{
	{TOPWAY_16BIT_ADDR_PARA_SYS_VOLT_HIGH,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fSysSetOverVolt},			// = 0x00080F00,		//系统参数 系统过压点
	{TOPWAY_16BIT_ADDR_PARA_SYS_WALKIN_TIME,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fRectLoadStartTime},			// = 0x00080F02,	//系统参数 软启动时间
	{TOPWAY_16BIT_ADDR_PARA_SYS_CURR_MAX,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fMaxOutCurr},				//= 0x00080F04,		//系统参数 最大电流
	{TOPWAY_16BIT_ADDR_PARA_SYS_VOLT_MAX,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fMaxOutVolt},				// = 0x00080F06,		//系统参数 最大电压
	{TOPWAY_16BIT_ADDR_PARA_SYS_OFFLINE_CHG_EN,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8NET_OffLine_Charge_Enable},// = 0x00080F08,	//系统参数 离线充电允许
	{TOPWAY_16BIT_ADDR_PARA_SYS_OFFLINE_CHG_TIME,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fMaxOffLineTime},			// = 0x00080F0A,//系统参数 最大允许离线充电时间
	{TOPWAY_16BIT_ADDR_PARA_SYS_METERING_WAY,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8SetCalcMoneyType},			// = 0x00080F0C,	//系统参数 计量方式
	{TOPWAY_16BIT_ADDR_PARA_SYS_PWM_DIRECTION,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8PWMPolarityCover},			// = 0x00080F0E,	//系统参数 PWM控制极性
	{TOPWAY_16BIT_ADDR_PARA_SYS_CARDREADER_TYPE,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8BrushFactorType},			// = 0x00080F10,//系统参数 刷卡机类型
	{TOPWAY_16BIT_ADDR_PARA_SYS_FAN_START_TEM,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8EV_StartTemp},				// = 0x00080F12,	//系统参数 风扇起转温度
	{TOPWAY_16BIT_ADDR_PARA_SYS_FAN_FULL_TEM,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8EV_StopTemp},				// = 0x00080F14,	//系统参数 风扇满转温度
	{TOPWAY_16BIT_ADDR_PARA_SYS_DOOR_MASK,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8DoorAlmMask_1},			// = 0x00080F16,		//系统参数 门禁屏蔽
	{TOPWAY_16BIT_ADDR_PARA_SYS_SPD_MASK,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8SPDAlmMask},				// = 0x00080F18,		//系统参数 SPD屏蔽
	{TOPWAY_16BIT_ADDR_PARA_SYS_PARALL_MODE,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_ParallelMode},				// = 0x00080F1A,	//系统参数 并机模式
	{TOPWAY_16BIT_ADDR_PARA_SYS_BRUSH_MASK,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8BRUSH_ALM_Mask},			// = 0x00080F1C,	//系统参数 刷卡故障屏蔽
	{TOPWAY_16BIT_ADDR_PARA_SYS_EPO_ACTIVE_MODE,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8EPOAlmVltLEVEL},			// = 0x00080F1E,//系统参数 EPO告警电平

	{TOPWAY_16BIT_ADDR_PARA_SYS_NET_MASK,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_SETDATA_MASK_NET_NUM},		 // = 0x00080F30,		//系统参数 网络屏蔽
	{TOPWAY_16BIT_ADDR_PARA_SYS_DHCP_EN,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_NET_DHCP},					// = 0x00080F32,		//系统参数 DHCP使能
	{TOPWAY_16BIT_ADDR_PARA_SYS_SERVER_ACCESS_WAY,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_SETDATA_RemoteServerIsDomainName_NUM},		 // = 0x00080F34,//系统参数 服务器访问模式
	{TOPWAY_16BIT_ADDR_PARA_SYS_SERVER_PORT,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u32NET_PORT},				// = 0x00080F36,	//系统参数 服务器端口号
	{TOPWAY_16BIT_ADDR_PARA_SYS_IP1,				DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8IP_1},		// = 0x00080F38,			//系统参数 IP1
	{TOPWAY_16BIT_ADDR_PARA_SYS_IP2,				DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8IP_2},		 // = 0x00080F3A,			//系统参数 IP2
	{TOPWAY_16BIT_ADDR_PARA_SYS_IP3,				DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8IP_3},		 // = 0x00080F3C,			//系统参数 IP3
	{TOPWAY_16BIT_ADDR_PARA_SYS_IP4,				DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8IP_4},		 // = 0x00080F3E,			//系统参数 IP4
	{TOPWAY_16BIT_ADDR_PARA_SYS_MASK_IP1,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8Subnetmask_1},		 // = 0x00080F40,		//系统参数 MASK IP1
	{TOPWAY_16BIT_ADDR_PARA_SYS_MASK_IP2,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8Subnetmask_2},		 // = 0x00080F42,		//系统参数 MASK IP2
	{TOPWAY_16BIT_ADDR_PARA_SYS_MASK_IP3,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8Subnetmask_3},		 // = 0x00080F44,		//系统参数 MASK IP3
	{TOPWAY_16BIT_ADDR_PARA_SYS_MASK_IP4,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8Subnetmask_4},		 // = 0x00080F46,		//系统参数 MASK IP4
	{TOPWAY_16BIT_ADDR_PARA_SYS_GATE_IP1,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8Gateway_1},		 // = 0x00080F48,		//系统参数 GATE IP1
	{TOPWAY_16BIT_ADDR_PARA_SYS_GATE_IP2,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8Gateway_2},		 // = 0x00080F4A,		//系统参数 GATE IP2
	{TOPWAY_16BIT_ADDR_PARA_SYS_GATE_IP3,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8Gateway_3},		 // = 0x00080F4C,		//系统参数 GATE IP3
	{TOPWAY_16BIT_ADDR_PARA_SYS_GATE_IP4,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8Gateway_4},		 // = 0x00080F4E,		//系统参数 GATE IP4
	{TOPWAY_16BIT_ADDR_PARA_SYS_SERVER_IP1,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8PowerStarIP_1},		 // = 0x00080F50,		//系统参数 SERVER IP1
	{TOPWAY_16BIT_ADDR_PARA_SYS_SERVER_IP2,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8PowerStarIP_2},		 // = 0x00080F52,		//系统参数 SERVER IP2
	{TOPWAY_16BIT_ADDR_PARA_SYS_SERVER_IP3,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8PowerStarIP_3},		 // = 0x00080F54,		//系统参数 SERVER IP3
	{TOPWAY_16BIT_ADDR_PARA_SYS_SERVER_IP4,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8PowerStarIP_4},		 // = 0x00080F56,		//系统参数 SERVER IP4
	{TOPWAY_16BIT_ADDR_PARA_SYS_DNS_IP1,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_SETDATA_DNSServerIP_NUM_1},		 // = 0x00080F58,		//系统参数 DNS IP1
	{TOPWAY_16BIT_ADDR_PARA_SYS_DNS_IP2,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_SETDATA_DNSServerIP_NUM_2},		 // = 0x00080F5A,		//系统参数 DNS IP2
	{TOPWAY_16BIT_ADDR_PARA_SYS_DNS_IP3,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_SETDATA_DNSServerIP_NUM_3},		 // = 0x00080F5C,		//系统参数 DNS IP3
	{TOPWAY_16BIT_ADDR_PARA_SYS_DNS_IP4,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_SETDATA_DNSServerIP_NUM_4},		 // = 0x00080F5E,		//系统参数 DNS IP4

	//A枪参数 0x00081200~0x00812FF	
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_ELOCK_EN,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8HasElec_ALock},		 // = 0x00081200,			//A枪 电子锁有无
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_ELOCK_TYPE,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8_A_LOCKType},		 // = 0x00081202,		//A枪 电子锁类型 0-脉冲 1-电平
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_LOCK_STAT,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8LOCK_A_DIType},		 // = 0x00081204,		//A枪 锁止状态
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_METER_TYPE,		DISP_RATIO_NORMAL, E_TYPE_WH1, SIGTYPE_RESERVE,			ID_u8WH_TYPE},		 // = 0x00081206,		//A枪 电表类型
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_METER_MASK,		DISP_RATIO_NORMAL, E_TYPE_WH1, SIGTYPE_RESERVE,			ID_u8WH_ALM_Mask},		 // = 0x00081208,		//A枪 屏蔽电表
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_AC_METER_RATIO,	DISP_RATIO_NORMAL, E_TYPE_WH1, SIGTYPE_RESERVE,			ID_fACWhCoef},		 // = 0x0008120A,	//A枪 交流表变比
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_BMS_VOLT_SEL,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_1_BMS_POWER},		 // = 0x0008120C,		//A枪 BMS辅助电源类型选择 0-12V 1-24V
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_BMS_VER2011_EN,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8_A_ForceVer2011},		 // = 0x0008120E,	//A枪 强制21011
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_CURR_LIMIT_EN,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fSetLimitMaxOutCurr_1},		 // = 0x00081210,	//A枪 限制电流
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_POLALITY_MASK,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8PolarityAlmMask_1},		 // = 0x00081212,	//A枪 极性告警屏蔽
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_CC1_EN,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8CC1CheckEnable_1},		 // = 0x00081214,			//A枪 CC1使能
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_SELF_CHK_EN,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8SelfTestEnable_1},		 // = 0x00081216,		//A枪 自检使能
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_PRE_CHG_EN,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8MCCBOnCheckEnable_1},		 // = 0x00081218,		//A枪 预充使能
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_OVER_VOLT_EN,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8OutOverVoltEnable_1},		 // = 0x0008121A,		//A枪 过压使能
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_INSUL_MASK,		DISP_RATIO_NORMAL, E_TYPE_IMIU1, SIGTYPE_RESERVE,		ID_u8JYMAlmStatMask},		 // = 0x0008121C,		//A枪 绝缘屏蔽
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_INSUL_TYPE,		DISP_RATIO_NORMAL, E_TYPE_IMIU1, SIGTYPE_RESERVE,		ID_u8SetJYMCtrlMode},		 // = 0x0008121E,		//A枪 绝缘交互方式
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_INSUL_CHK_TYPE,	DISP_RATIO_NORMAL, E_TYPE_IMIU1, SIGTYPE_RESERVE,		ID_u8InsltCheckByVolt},		 // = 0x00081220,	//A枪 绝缘检测方式
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_INSUL_ALM_VALUE,	DISP_RATIO_NORMAL, E_TYPE_IMIU1, SIGTYPE_RESERVE,		ID_fSetJYMAlm_Resist},		 // = 0x00081222,	//A枪 绝缘告警值

	{TOPWAY_16BIT_ADDR_PARA_GUN_A_T1,				DISP_RATIO_X10, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u32_A_CTS_DB_T1},		 // = 0x00081224,				//A枪 T1
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_T2,				DISP_RATIO_X10, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u32_A_DB_DB_T2},		 // = 0x00081226,				//A枪 T2
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_T3,				DISP_RATIO_X10, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u16SetBCLTimeOutVal_1},		 // = 0x00081228,				//A枪 T3
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_T4,				DISP_RATIO_X10, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u16SetBRMTimeOutVal_1},		 // = 0x0008122A,				//A枪 T4
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_CC1_COEFF_K,		DISP_RATIO_X10000, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fCC1_1Coef_A},		 // = 0x0008122C,		//A枪 CC1 系数K
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_CC1_COEFF_B,		DISP_RATIO_X10, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fCC1_1Coef_B},		 // = 0x0008122E,		//A枪 CC1 系数B
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_BATT_V_COEFF_K,	DISP_RATIO_X10000, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fBattVolt_1CoefA},		 // = 0x00081230,	//A枪 电池电压 系数K
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_BATT_V_COEFF_B,	DISP_RATIO_X10, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fBattVolt_1CoefB},		 // = 0x00081232,	//A枪 电池电压 系数B
	{TOPWAY_16BIT_ADDR_PARA_GUN_A_T5,				DISP_RATIO_X10, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u16SetBCSTimeOutVal_1},		 // = 0x0008222A,				//B枪 T4
	{TOPWAY_16BIT_ADDR_PARA_INSLT_COEFF,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fInsulationAlmCoeff},		 // = 0x00081236,	//A枪 绝缘告警值


	//B枪参数 0x00081200~0x00812FF	
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_ELOCK_EN,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8HasElec_BLock},		 // = 0x00082200,			//B枪 电子锁有无
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_ELOCK_TYPE,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8_B_LOCKType},		 // = 0x00082202,		//B枪 电子锁类型 0-脉冲 1-电平
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_LOCK_STAT,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8LOCK_B_DIType},		 // = 0x00082204,		//B枪 锁止状态
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_METER_TYPE,		DISP_RATIO_NORMAL, E_TYPE_WH2, SIGTYPE_RESERVE,			ID_u8WH_TYPE},		 // = 0x00082206,		//B枪 电表类型
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_METER_MASK,		DISP_RATIO_NORMAL, E_TYPE_WH2, SIGTYPE_RESERVE,			ID_u8WH_ALM_Mask},		 // = 0x00082208,		//B枪 屏蔽电表
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_AC_METER_RATIO,	DISP_RATIO_NORMAL, E_TYPE_WH2, SIGTYPE_RESERVE,			ID_fACWhCoef},		 // = 0x0008220A,	//B枪 交流表变比
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_BMS_VOLT_SEL,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_2_BMS_POWER},		 // = 0x0008220C,		//B枪 BMS辅助电源类型选择 0-12V 1-24V
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_BMS_VER2011_EN,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8_B_ForceVer2011},		 // = 0x0008220E,	//B枪 强制21011
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_CURR_LIMIT_EN,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fSetLimitMaxOutCurr_2},		 // = 0x00082210,	//B枪 限制电流
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_POLALITY_MASK,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8PolarityAlmMask_2},		 // = 0x00082212,	//B枪 极性告警屏蔽
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_CC1_EN,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8CC1CheckEnable_2},		 // = 0x00082214,			//B枪 CC1使能
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_SELF_CHK_EN,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8SelfTestEnable_2},		 // = 0x00082216,		//B枪 自检使能
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_PRE_CHG_EN,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8MCCBOnCheckEnable_2},		 // = 0x00082218,		//B枪 预充使能
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_OVER_VOLT_EN,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8OutOverVoltEnable_2},		 // = 0x0008221A,		//B枪 过压使能
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_INSUL_MASK,		DISP_RATIO_NORMAL, E_TYPE_IMIU2, SIGTYPE_RESERVE,		ID_u8JYMAlmStatMask},		 // = 0x0008221C,		//B枪 绝缘屏蔽
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_INSUL_TYPE,		DISP_RATIO_NORMAL, E_TYPE_IMIU2, SIGTYPE_RESERVE,		ID_u8SetJYMCtrlMode},		 // = 0x0008221E,		//B枪 绝缘交互方式
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_INSUL_CHK_TYPE,	DISP_RATIO_NORMAL, E_TYPE_IMIU2, SIGTYPE_RESERVE,		ID_u8InsltCheckByVolt},		 // = 0x00082220,	//B枪 绝缘检测方式
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_INSUL_ALM_VALUE,	DISP_RATIO_NORMAL, E_TYPE_IMIU2, SIGTYPE_RESERVE,		ID_fSetJYMAlm_Resist},		 // = 0x00082222,	//B枪 绝缘告警值
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_T1,				DISP_RATIO_X10,	   E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u32_B_CTS_DB_T1},		 // = 0x00082224,				//B枪 T1
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_T2,				DISP_RATIO_X10,    E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u32_B_DB_DB_T2},		 // = 0x00082226,				//B枪 T2
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_T3,				DISP_RATIO_X10,	   E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u16SetBCLTimeOutVal_2},		 // = 0x00082228,				//B枪 T3
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_T4,				DISP_RATIO_X10,    E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u16SetBRMTimeOutVal_2},		 // = 0x0008222A,				//B枪 T4
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_CC1_COEFF_K,		DISP_RATIO_X10000, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fCC1_2Coef_A},		 // = 0x0008222C,		//B枪 CC1 系数K
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_CC1_COEFF_B,		DISP_RATIO_X10, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fCC1_2Coef_B},		 // = 0x0008222E,		//B枪 CC1 系数B
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_BATT_V_COEFF_K,	DISP_RATIO_X10000, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fBattVolt_2CoefA},		 // = 0x00082230,	//B枪 电池电压 系数K
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_BATT_V_COEFF_B,	DISP_RATIO_X10, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fBattVolt_2CoefB},		 // = 0x00082232,	//B枪 电池电压 系数B
	{TOPWAY_16BIT_ADDR_PARA_GUN_B_T5,				DISP_RATIO_X10, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u16SetBCSTimeOutVal_2},		 // = 0x0008222A,				//B枪 T5

	//费率 参数 0x00080B00~0x0080BFF
	{TOPWAY_16BIT_ADDR_PARA_FEE_MODE,				DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_SETDATA_FeeMode_NUM},	//TOPWAY_16BIT_ADDR_PARA_FEE_MODE = 0x00080A00,			//费率参数 
	{TOPWAY_16BIT_ADDR_PARA_SERVICE_FEE_MODE,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_SETDATA_ServiceFeeMode_NUM},//	TOPWAY_16BIT_ADDR_PARA_SERVICE_FEE_MODE = 0x00080A02,	//费率参数 
	
	//注意：以下费率改成32bit参数了
	{TOPWAY_16BIT_ADDR_PARA_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_SETDATA_fServicePrice_NUM},//TOPWAY_16BIT_ADDR_PARA_SERVICE_PRICE = 0x00080A04,		//费率参数 
	{TOPWAY_16BIT_ADDR_PARA_FIX_PRICE,				DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_SETDATA_fFixPrice_NUM},//TOPWAY_16BIT_ADDR_PARA_FIX_PRICE = 0x00080A06,			//费率参数 
	{TOPWAY_16BIT_ADDR_PARA_TIME1_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+0},//
	{TOPWAY_16BIT_ADDR_PARA_TIME2_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+1},//
	{TOPWAY_16BIT_ADDR_PARA_TIME3_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+2},//
	{TOPWAY_16BIT_ADDR_PARA_TIME4_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+3},//
	{TOPWAY_16BIT_ADDR_PARA_TIME5_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+4},//
	{TOPWAY_16BIT_ADDR_PARA_TIME6_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+5},//
	{TOPWAY_16BIT_ADDR_PARA_TIME7_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+6},//
	{TOPWAY_16BIT_ADDR_PARA_TIME8_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+7},//
	{TOPWAY_16BIT_ADDR_PARA_TIME9_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+8},//
	{TOPWAY_16BIT_ADDR_PARA_TIME10_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+9},//

	{TOPWAY_16BIT_ADDR_PARA_TIME11_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+10},//
	{TOPWAY_16BIT_ADDR_PARA_TIME12_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+11},//
	{TOPWAY_16BIT_ADDR_PARA_TIME13_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+12},//
	{TOPWAY_16BIT_ADDR_PARA_TIME14_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+13},//
	{TOPWAY_16BIT_ADDR_PARA_TIME15_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+14},//
	{TOPWAY_16BIT_ADDR_PARA_TIME16_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+15},//
	{TOPWAY_16BIT_ADDR_PARA_TIME17_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+16},//
	{TOPWAY_16BIT_ADDR_PARA_TIME18_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+17},//
	{TOPWAY_16BIT_ADDR_PARA_TIME19_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+18},//
	{TOPWAY_16BIT_ADDR_PARA_TIME20_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+19},//

	{TOPWAY_16BIT_ADDR_PARA_TIME21_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+20},//
	{TOPWAY_16BIT_ADDR_PARA_TIME22_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+21},//
	{TOPWAY_16BIT_ADDR_PARA_TIME23_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+22},//
	{TOPWAY_16BIT_ADDR_PARA_TIME24_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+23},//
	{TOPWAY_16BIT_ADDR_PARA_TIME25_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+24},//
	{TOPWAY_16BIT_ADDR_PARA_TIME26_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+25},//
	{TOPWAY_16BIT_ADDR_PARA_TIME27_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+26},//
	{TOPWAY_16BIT_ADDR_PARA_TIME28_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+27},//
	{TOPWAY_16BIT_ADDR_PARA_TIME29_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+28},//
	{TOPWAY_16BIT_ADDR_PARA_TIME30_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+29},//

	{TOPWAY_16BIT_ADDR_PARA_TIME31_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+30},//
	{TOPWAY_16BIT_ADDR_PARA_TIME32_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+31},//
	{TOPWAY_16BIT_ADDR_PARA_TIME33_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+32},//
	{TOPWAY_16BIT_ADDR_PARA_TIME34_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+33},//
	{TOPWAY_16BIT_ADDR_PARA_TIME35_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+34},//
	{TOPWAY_16BIT_ADDR_PARA_TIME36_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+35},//
	{TOPWAY_16BIT_ADDR_PARA_TIME37_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+36},//
	{TOPWAY_16BIT_ADDR_PARA_TIME38_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+37},//
	{TOPWAY_16BIT_ADDR_PARA_TIME39_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+38},//
	{TOPWAY_16BIT_ADDR_PARA_TIME40_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+39},//

	{TOPWAY_16BIT_ADDR_PARA_TIME41_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+40},//
	{TOPWAY_16BIT_ADDR_PARA_TIME42_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+41},//
	{TOPWAY_16BIT_ADDR_PARA_TIME43_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+42},//
	{TOPWAY_16BIT_ADDR_PARA_TIME44_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+43},//
	{TOPWAY_16BIT_ADDR_PARA_TIME45_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+44},//
	{TOPWAY_16BIT_ADDR_PARA_TIME46_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+45},//
	{TOPWAY_16BIT_ADDR_PARA_TIME47_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+46},//
	{TOPWAY_16BIT_ADDR_PARA_TIME48_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimePrice1+47},//

	{TOPWAY_16BIT_ADDR_PARA_TIME1_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+0},//
	{TOPWAY_16BIT_ADDR_PARA_TIME2_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+1},//
	{TOPWAY_16BIT_ADDR_PARA_TIME3_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+2},//
	{TOPWAY_16BIT_ADDR_PARA_TIME4_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+3},//
	{TOPWAY_16BIT_ADDR_PARA_TIME5_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+4},//
	{TOPWAY_16BIT_ADDR_PARA_TIME6_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+5},//
	{TOPWAY_16BIT_ADDR_PARA_TIME7_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+6},//
	{TOPWAY_16BIT_ADDR_PARA_TIME8_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+7},//
	{TOPWAY_16BIT_ADDR_PARA_TIME9_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+8},//
	{TOPWAY_16BIT_ADDR_PARA_TIME10_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+9},//

	{TOPWAY_16BIT_ADDR_PARA_TIME11_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+10},//
	{TOPWAY_16BIT_ADDR_PARA_TIME12_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+11},//
	{TOPWAY_16BIT_ADDR_PARA_TIME13_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+12},//
	{TOPWAY_16BIT_ADDR_PARA_TIME14_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+13},//
	{TOPWAY_16BIT_ADDR_PARA_TIME15_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+14},//
	{TOPWAY_16BIT_ADDR_PARA_TIME16_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+15},//
	{TOPWAY_16BIT_ADDR_PARA_TIME17_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+16},//
	{TOPWAY_16BIT_ADDR_PARA_TIME18_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+17},//
	{TOPWAY_16BIT_ADDR_PARA_TIME19_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+18},//
	{TOPWAY_16BIT_ADDR_PARA_TIME20_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+19},//

	{TOPWAY_16BIT_ADDR_PARA_TIME21_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+20},//
	{TOPWAY_16BIT_ADDR_PARA_TIME22_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+21},//
	{TOPWAY_16BIT_ADDR_PARA_TIME23_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+22},//
	{TOPWAY_16BIT_ADDR_PARA_TIME24_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+23},//
	{TOPWAY_16BIT_ADDR_PARA_TIME25_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+24},//
	{TOPWAY_16BIT_ADDR_PARA_TIME26_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+25},//
	{TOPWAY_16BIT_ADDR_PARA_TIME27_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+26},//
	{TOPWAY_16BIT_ADDR_PARA_TIME28_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+27},//
	{TOPWAY_16BIT_ADDR_PARA_TIME29_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+28},//
	{TOPWAY_16BIT_ADDR_PARA_TIME30_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+29},//

	{TOPWAY_16BIT_ADDR_PARA_TIME31_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+30},//
	{TOPWAY_16BIT_ADDR_PARA_TIME32_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+31},//
	{TOPWAY_16BIT_ADDR_PARA_TIME33_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+32},//
	{TOPWAY_16BIT_ADDR_PARA_TIME34_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+33},//
	{TOPWAY_16BIT_ADDR_PARA_TIME35_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+34},//
	{TOPWAY_16BIT_ADDR_PARA_TIME36_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+35},//
	{TOPWAY_16BIT_ADDR_PARA_TIME37_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+36},//
	{TOPWAY_16BIT_ADDR_PARA_TIME38_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+37},//
	{TOPWAY_16BIT_ADDR_PARA_TIME39_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+38},//
	{TOPWAY_16BIT_ADDR_PARA_TIME40_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+39},//

	{TOPWAY_16BIT_ADDR_PARA_TIME41_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+40},//
	{TOPWAY_16BIT_ADDR_PARA_TIME42_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+41},//
	{TOPWAY_16BIT_ADDR_PARA_TIME43_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+42},//
	{TOPWAY_16BIT_ADDR_PARA_TIME44_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+43},//
	{TOPWAY_16BIT_ADDR_PARA_TIME45_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+44},//
	{TOPWAY_16BIT_ADDR_PARA_TIME46_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+45},//
	{TOPWAY_16BIT_ADDR_PARA_TIME47_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+46},//
	{TOPWAY_16BIT_ADDR_PARA_TIME48_SERVICE_PRICE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fTimeServicePrice1+47},//

	{TOPWAY_32BIT_ADDR_PARA_GUN_A_ACWhCoef,			DISP_RATIO_NORMAL, E_TYPE_WH1, SIGTYPE_RESERVE,			ID_fACWhCoef},//
	{TOPWAY_32BIT_ADDR_PARA_GUN_B_ACWhCoef,			DISP_RATIO_NORMAL, E_TYPE_WH2, SIGTYPE_RESERVE,			ID_fACWhCoef},//

	//{TOPWAY_16BIT_ADDR_PARA_GUN_A_INSUL_TYPE,		DISP_RATIO_NORMAL, E_TYPE_IMIU1, SIGTYPE_RESERVE,		ID_u8SetJYMCtrlMode},//
	//{TOPWAY_16BIT_ADDR_PARA_GUN_B_INSUL_TYPE,		DISP_RATIO_NORMAL, E_TYPE_IMIU2, SIGTYPE_RESERVE,		ID_u8SetJYMCtrlMode},//

	//{TOPWAY_16BIT_ADDR_PARA_GUN_A_INSUL_CHK_TYPE,	DISP_RATIO_NORMAL, E_TYPE_IMIU1, SIGTYPE_RESERVE,		ID_u8InsltCheckByVolt},//
	//{TOPWAY_16BIT_ADDR_PARA_GUN_B_INSUL_CHK_TYPE,	DISP_RATIO_NORMAL, E_TYPE_IMIU2, SIGTYPE_RESERVE,		ID_u8InsltCheckByVolt},//

	//{TOPWAY_16BIT_ADDR_PARA_GUN_A_INSUL_ALM_VALUE,	DISP_RATIO_NORMAL, E_TYPE_IMIU1, SIGTYPE_RESERVE,		ID_fSetJYMAlm_Resist},//
	//{TOPWAY_16BIT_ADDR_PARA_GUN_B_INSUL_ALM_VALUE,	DISP_RATIO_NORMAL, E_TYPE_IMIU2, SIGTYPE_RESERVE,		ID_fSetJYMAlm_Resist},//

	{TOPWAY_16BIT_ADDR_PARA_ADJUST_MODE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_SETDATA_AdjustMode_NUM},//
	{TOPWAY_16BIT_ADDR_PARA_ADJUST_VOLT1,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_SETDATA_Adjust_Volt1},//
	{TOPWAY_16BIT_ADDR_PARA_ADJUST_VOLT2,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_SETDATA_Adjust_Volt2},//

	{TOPWAY_16BIT_ADDR_ABOUT_SOFTWARE_VER,			DISP_RATIO_X100,   E_TYPE_SYS, SIGTYPE_RESERVE,			ID_SETDATA_SoftwareVersion_NUM},//
	{TOPWAY_16BIT_ADDR_ABOUT_CONFIG_VER,			DISP_RATIO_X100,   E_TYPE_SYS, SIGTYPE_RESERVE,			ID_SETDATA_SetDataVersion_NUM},//	

	{TOPWAY_16BIT_ADDR_PARA_SYS_QRCODE_SOURCE,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_SETDATA_EVChargeCodeOnUI_NUM},		 // = 0x00080F60,		//系统参数 二维码来源

	{TOPWAY_16BIT_ADDR_PARA_SYS_RING_EN,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8IsRingEnabled},
	{TOPWAY_16BIT_ADDR_PARA_SYS_RING_MERGE_CURR,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fRingStartMergeCurr},
	{TOPWAY_16BIT_ADDR_PARA_SYS_RING_CHG_ID,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_bySelfAddress},

	{TOPWAY_16BIT_ADDR_PARA_SYS_RING_CHG_AMOUNT,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_nTotalRingStub},
	{TOPWAY_16BIT_ADDR_PARA_SYS_RING_MODE,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_bIsGunInsertMode},
	{TOPWAY_16BIT_ADDR_PARA_SYS_RING_GUNIN_TIME_S_H,DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_nGunInsertMode_Start_Hour},
	{TOPWAY_16BIT_ADDR_PARA_SYS_RING_GUNIN_TIME_S_M,DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_nGunInsertMode_Start_Min},
	{TOPWAY_16BIT_ADDR_PARA_SYS_RING_GUNIN_TIME_E_H,DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_nGunInsertMode_Stop_Hour},
	{TOPWAY_16BIT_ADDR_PARA_SYS_RING_GUNIN_TIME_E_M,DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_nGunInsertMode_Stop_Min},
		
	{TOPWAY_16BIT_ADDR_PARA_SYS_RING_PWRLMT,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_AllRingsPwrLmt},
	{TOPWAY_16BIT_ADDR_PARA_SYS_RING_CURR_INC_SPEED,DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_RingChgCurrIncSpeed},
	{TOPWAY_16BIT_ADDR_PARA_SYS_IS_SINGLE_GUN_MODE,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_IsSingleGunMode},
	{TOPWAY_16BIT_ADDR_PARA_SYS_fContactorShortThreshold,DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,	ID_fContactorShortThreshold},

	{TOPWAY_16BIT_ADDR_PARA_SYS_EN_GUN_OVERTEM_DI,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_EnGunOverTemDi},
	{TOPWAY_16BIT_ADDR_PARA_SYS_GUN_OVERTEM_LMT_CURR,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,		ID_fGunOverTemLmtCurrRatio},
	{TOPWAY_16BIT_ADDR_PARA_SYS_EN_GUN_OVERTEM_DI_ALMSTAT,DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,	ID_GunOverTemDiAlmStat},
	{TOPWAY_16BIT_ADDR_PARA_SYS_EN_GUN_OVERTEM_INTERVAL_TIME,DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,ID_fGunOverTemIntervalTime},
	{TOPWAY_16BIT_ADDR_PARA_SYS_u8ShuimuAutoEndSoc,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8ShuimuAutoEndSoc},

	{TOPWAY_16BIT_ADDR_PARA_SYS_StChgByOverVoltOrCurrSource, DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,ID_StChgByOverVoltOrCurr_Source},
	{TOPWAY_16BIT_ADDR_PARA_SYS_VOLT_MIN,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fMinOutVolt},	
	{TOPWAY_16BIT_ADDR_PARA_SYS_u8FanMaxSpeed,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,				ID_u8FanMaxSpeed},
	{TOPWAY_16BIT_ADDR_PARA_SYS_u8VinChgEn,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,					ID_u8VinChgEn},
	{TOPWAY_16BIT_ADDR_PARA_SYS_u8ButtonChgEn,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,				ID_u8ButtonChgEn},
	{TOPWAY_16BIT_ADDR_PARA_SYS_u8ChgModeSelEn,	DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,				ID_u8ChgModeSelEn},
	{TOPWAY_32BIT_ADDR_PARA_DC_METER_RATIO,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_fDCMeterRatio},//
	{TOPWAY_16BIT_ADDR_PARA_SYS_SERVER2_IP1,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8PowerStar2IP_1},		 // = 0x00080F50,		//系统参数 SERVER IP1
	{TOPWAY_16BIT_ADDR_PARA_SYS_SERVER2_IP2,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8PowerStar2IP_2},		 // = 0x00080F52,		//系统参数 SERVER IP2
	{TOPWAY_16BIT_ADDR_PARA_SYS_SERVER2_IP3,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8PowerStar2IP_3},		 // = 0x00080F54,		//系统参数 SERVER IP3
	{TOPWAY_16BIT_ADDR_PARA_SYS_SERVER2_IP4,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8PowerStar2IP_4},		 // = 0x00080F56,		//系统参数 SERVER IP4
	{TOPWAY_16BIT_ADDR_PARA_SYS_SERVER2_Enable,			DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8Server2Enable},		 // = 0x00080F30,		//系统参数 网络屏蔽
	{TOPWAY_16BIT_ADDR_PARA_SYS_SERVER2_PORT,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u32NET_PORT2},				// = 0x00080F36,	//系统参数 服务器端口号
	{TOPWAY_16BIT_ADDR_PARA_SYS_u8ACInputContactorOpenDelay,DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,		ID_u8ACInputContactorOpenDelay},
	{TOPWAY_16BIT_ADDR_PARA_SYS_u8DoorOpenDisconACInput,DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,		ID_u8DoorOpenDisconACInput},
	{TOPWAY_16BIT_ADDR_PARA_User_Set_BMS_Power,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8UserSetBMSPower},
	{TOPWAY_16BIT_ADDR_PARA_Display_StopKey,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8DisplayStopKey},
	{TOPWAY_16BIT_ADDR_PARA_Order_Charge_Enable,		DISP_RATIO_NORMAL, E_TYPE_SYS, SIGTYPE_RESERVE,			ID_u8OrderChargeEnable},
};

static unsigned short s_u16DispSigMapNum = sizeof(s_DispSigMap) / sizeof(DispSigMap_Def);


unsigned short  u16TopwayGet16BitCfgSignal(unsigned long TopwayRegAddr)
{
	__XXX_UNION_VALUE unTempVal;
	unsigned short ii;
	unsigned char	u8SigType;	
	//INT32 iTempVal = 0;
	//void *PEInfo;
	//static struct tm  tmNow;
	//void *PEInfo_2;
	UNUSED(TopwayRegAddr);
	UINT16 u16Value = 0;
	float fRatio;
	UNUSED(u16Value);

	for(ii = 0; ii < s_u16DispSigMapNum; ii++)
	{
		if(s_DispSigMap[ii].u32DispSigAddr == TopwayRegAddr)
		{
			ExGetSigInfo(s_DispSigMap[ii].u8Etype, s_DispSigMap[ii].u16Idx, &unTempVal, &u8SigType, BY_SRAM);
			
			if(u8SigType == IS_CHAR)
			{
				u16Value = unTempVal.chtemp[0];				
			}
			else if(u8SigType == IS_FLOAT)
			{
				switch(s_DispSigMap[ii].u8Ratio)
				{
					case DISP_RATIO_X10000:
						fRatio = 10000;
						break;
					case DISP_RATIO_X1000:
						fRatio = 1000;
						break;
					case DISP_RATIO_X10:
						fRatio = 10;
						break;
					case DISP_RATIO_X100:
						fRatio = 100;
						break;
					default:
						fRatio = 1;
						break;
				}

				u16Value = (unsigned short)(unTempVal.ftemp * fRatio);
			}
			else if(u8SigType == IS_ULONG)
			{
				switch(s_DispSigMap[ii].u8Ratio)
				{
					case DISP_RATIO_X10000:
						fRatio = 10000;
						break;
					case DISP_RATIO_X1000:
						fRatio = 1000;
						break;
					case DISP_RATIO_X10:
						fRatio = 10;
						break;
					case DISP_RATIO_X100:
						fRatio = 100;
						break;
					default:
						fRatio = 1;
						break;
				}

				u16Value = (UINT16)(unTempVal.u32Value*fRatio);
			}

			return u16Value;
			
		}
	}


	return u16Value;
}

//在DHCP使能情况下，上报的IP、MASK/GATEWAY要用DHCP动态所获取的值
UINT16 u16TopwayGetDHCPNetInfo(unsigned long TopwayRegAddr)
{
	UINT16 u16Value = 0;
	unsigned char u8Idx;

	switch (TopwayRegAddr)
	{
		case TOPWAY_16BIT_ADDR_PARA_SYS_IP1:
		case TOPWAY_16BIT_ADDR_PARA_SYS_IP2:
		case TOPWAY_16BIT_ADDR_PARA_SYS_IP3:
		case TOPWAY_16BIT_ADDR_PARA_SYS_IP4:
			u8Idx = (unsigned char)((TopwayRegAddr - TOPWAY_16BIT_ADDR_PARA_SYS_IP1)/2);
			u16Value = gEvChargeInfo.stDHCPNetInfo.u8IP[u8Idx];
			break;

		case TOPWAY_16BIT_ADDR_PARA_SYS_MASK_IP1:
		case TOPWAY_16BIT_ADDR_PARA_SYS_MASK_IP2:
		case TOPWAY_16BIT_ADDR_PARA_SYS_MASK_IP3:
		case TOPWAY_16BIT_ADDR_PARA_SYS_MASK_IP4:
			u8Idx = (unsigned char)((TopwayRegAddr - TOPWAY_16BIT_ADDR_PARA_SYS_MASK_IP1)/2);
			u16Value = gEvChargeInfo.stDHCPNetInfo.u8Mask[u8Idx];
			break;

		case TOPWAY_16BIT_ADDR_PARA_SYS_GATE_IP1:
		case TOPWAY_16BIT_ADDR_PARA_SYS_GATE_IP2:
		case TOPWAY_16BIT_ADDR_PARA_SYS_GATE_IP3:
		case TOPWAY_16BIT_ADDR_PARA_SYS_GATE_IP4:
			u8Idx = (unsigned char)((TopwayRegAddr - TOPWAY_16BIT_ADDR_PARA_SYS_GATE_IP1)/2);
			u16Value = gEvChargeInfo.stDHCPNetInfo.u8Gateway[u8Idx];
			break;

		default:
			break;
	}

	return u16Value;
}

//获取环网状态数据信息，放这里，以免u16TopwayGet16bitsSignal()函数太庞大
UINT16 u16TopwayGet16BitRingSignal(unsigned long TopwayRegAddr)
{
	UINT16 u16Value = 0;
	unsigned char u8NodeNo, u8SigNo;

	//环网信息节点0x3100~33FF
	if((TopwayRegAddr >= 0x00083100) && (TopwayRegAddr <= 0x833FF))
	{
		u8NodeNo = ((TopwayRegAddr - 0x00083100) / 0x10);
		u8SigNo = ((TopwayRegAddr - 0x00083100) % 0x10);

		if(u8NodeNo >=  MAX_SUPPORTED_RING_NODE)
		{
			return u16Value;
		}

		//TOPWAY_16BIT_ADDR_RING_Node1_LockStat = 0x00083100,			//环网 节点1锁定状态
		//TOPWAY_16BIT_ADDR_RING_Node1_MergeStat = 0x00083102,			//环网 节点1并网状态	
		//TOPWAY_16BIT_ADDR_RING_Node1_CommStat = 0x00083104,			//环网 节点1通信状态
		//TOPWAY_16BIT_ADDR_RING_Node1_MaxMergeCurr = 0x00083106,		//环网 节点1电流能力	
		//TOPWAY_16BIT_ADDR_RING_Node1_OutVolt = 0x00083108,			//环网 节点1输出电压
		//TOPWAY_16BIT_ADDR_RING_Node1_OutCurr = 0x0008310A,			//环网 节点1输出电流
		
		switch(u8SigNo)
		{
			case 0x00:	//环网 节点1锁定状态
				u16Value = g_RingAllInfo.allNodes[u8NodeNo].emLockState;
				if(gs_CANComm.bIsRingEnabled == FALSE)
				{
					u16Value = 2;
				}
				else if(g_RingAllInfo.allNodes[u8NodeNo].emLockState == _LOCK_NOT_AVAILABLE)
				{
					u16Value = 2;
				}
				else if(g_RingAllInfo.allNodes[u8NodeNo].emLockState == _LOCK_AS_SLAVE)
				{
					u16Value = 2 + g_RingAllInfo.allNodes[u8NodeNo].nLockedMasterID;
				}
				break;
			case 0x02:	//环网 节点1并网状态	
				u16Value = g_RingAllInfo.allNodes[u8NodeNo].emMergeStatus;
				break;
			case 0x04:	//环网 节点1通信状态
				u16Value = g_RingAllInfo.allNodes[u8NodeNo].bCommFail;
				if(g_RingAllInfo.allNodes[u8NodeNo].bIsExist == 0)
				{
					u16Value = 2;  //不存在
				}
				break;
			case 0x06:	//环网 节点1电流能力	
				u16Value = (UINT16)g_RingAllInfo.allNodes[u8NodeNo].fMaxMergeCurr;
				break;
			case 0x08:	//环网 节点1输出电压
				u16Value = (UINT16)g_RingAllInfo.allNodes[u8NodeNo].fOutVolt;
				break;
			case 0x0A:	//环网 节点1输出电流
				u16Value = (UINT16)g_RingAllInfo.allNodes[u8NodeNo].fOutCurr;
				break;
			default:
				break;
		}
			
		return u16Value;
	}

	switch (TopwayRegAddr)
	{
		//环网信息本桩0x3000~30FF
		case TOPWAY_16BIT_ADDR_RING_OnlineTotal:// = 0x00083000,			//环网 在线枪数
			u16Value = (UINT16)g_RingAllInfo.nOnlineTotal;
			break;

		case TOPWAY_16BIT_ADDR_RING_GunA_Addr:// = 0x00083002,				//环网 枪地址
			u16Value = (UINT16)g_pRing_A->pNodeMe->byNodeAddress;
			break;

		case TOPWAY_16BIT_ADDR_RING_GunA_LockStat:// = 0x00083004,			//环网 锁定状态
			if(gEvChargeInfo.u8IsRingEnabled == FALSE)
			{
				u16Value = 2;		//不可用
			}
			else
			{
				u16Value = (UINT16)g_pRing_A->pNodeMe->emLockState;
				if(g_pRing_A->pNodeMe->emLockState == _LOCK_NOT_AVAILABLE)
				{
					u16Value = 2;
				}
				else if(g_pRing_A->pNodeMe->emLockState == _LOCK_AS_SLAVE)
				{
					u16Value = 2 + g_pRing_A->pNodeMe->nLockedMasterID;
				}
			}
			break;

		case TOPWAY_16BIT_ADDR_RING_GunA_MergeStat:// = 0x00083006,			//环网 并网状态	
			if(gEvChargeInfo.u8IsRingEnabled == FALSE)
			{
				u16Value = 0;
			}
			else
			{
				u16Value = (UINT16)g_pRing_A->pNodeMe->emMergeStatus;
			}
			break;

		case TOPWAY_16BIT_ADDR_RING_GunA_OutVolt:// = 0x00083008,			//环网 输出电压
			u16Value = (UINT16)g_pRing_A->pNodeMe->fOutVolt;
			break;

		case TOPWAY_16BIT_ADDR_RING_GunA_OutCurr:// = 0x0008300A,			//环网 输出电流
			u16Value = (UINT16)g_pRing_A->pNodeMe->fOutCurr;
			break;

		case TOPWAY_16BIT_ADDR_RING_GunA_ReqMaxVolt:// = 0x0008300C,			//环网 作为主机时最大需求电压
			u16Value = (UINT16)g_pRing_A->master.fTotalReqVolt;
			break;

		case TOPWAY_16BIT_ADDR_RING_GunA_ReqMaxCurr:// = 0x0008300E,			//环网 作为主机时最大需求电流
			u16Value = (UINT16)g_pRing_A->master.fTotalReqCurr;
			break;

		case TOPWAY_16BIT_ADDR_RING_GunA_IDConflict: // = 0x00083010,			//环网 ID冲突状态
			if(gEvChargeInfo.u8IsRingEnabled == TRUE)
				u16Value = (UINT16)g_pRing_A->bSelfIDConflict;
			break;

		case TOPWAY_16BIT_ADDR_RING_GunB_Addr:// = 0x00083002,				//环网 枪地址
			u16Value = (UINT16)g_pRing_B->pNodeMe->byNodeAddress;
			break;

		case TOPWAY_16BIT_ADDR_RING_GunB_LockStat:// = 0x00083004,			//环网 锁定状态
			if(gEvChargeInfo.u8IsRingEnabled == FALSE)
			{
				u16Value = 2;
			}
			else
			{
				u16Value = (UINT16)g_pRing_B->pNodeMe->emLockState;
				if(g_pRing_B->pNodeMe->emLockState == _LOCK_NOT_AVAILABLE)
				{
					u16Value = 2;
				}
				else if(g_pRing_B->pNodeMe->emLockState == _LOCK_AS_SLAVE)
				{
					u16Value = 2 + g_pRing_B->pNodeMe->nLockedMasterID;
				}
			}
			break;

		case TOPWAY_16BIT_ADDR_RING_GunB_MergeStat:// = 0x00083006,			//环网 并网状态	
			if(gEvChargeInfo.u8IsRingEnabled == FALSE)
			{
				u16Value = 0;
			}
			else
			{
				u16Value = (UINT16)g_pRing_B->pNodeMe->emMergeStatus;
			}
			break;

		case TOPWAY_16BIT_ADDR_RING_GunB_OutVolt:// = 0x00083008,			//环网 输出电压
			u16Value = (UINT16)g_pRing_B->pNodeMe->fOutVolt;
			break;

		case TOPWAY_16BIT_ADDR_RING_GunB_OutCurr:// = 0x0008300A,			//环网 输出电流
			u16Value = (UINT16)g_pRing_B->pNodeMe->fOutCurr;
			break;

		case TOPWAY_16BIT_ADDR_RING_GunB_ReqMaxVolt:// = 0x0008300C,			//环网 作为主机时最大需求电压
			u16Value = (UINT16)g_pRing_B->master.fTotalReqVolt;
			break;

		case TOPWAY_16BIT_ADDR_RING_GunB_ReqMaxCurr:// = 0x0008300E,			//环网 作为主机时最大需求电流
			u16Value = (UINT16)g_pRing_B->master.fTotalReqCurr;
			break;

		case TOPWAY_16BIT_ADDR_RING_GunB_IDConflict: // = 0x00083010,			//环网 ID冲突状态
			if(gEvChargeInfo.u8IsRingEnabled == TRUE)
				u16Value = (UINT16)g_pRing_B->bSelfIDConflict;
			break;		

		default:
			break;
	}

	return u16Value;
}

//获取模块状态数据信息，放这里，以免u16TopwayGet16bitsSignal()函数太庞大
UINT16 u16TopwayGet16BitRectSignal(unsigned long TopwayRegAddr)
{
	UINT16 u16Value = 0;
	unsigned char u8NodeNo, u8SigNo;
	union
	{
		unsigned short u16temp;
		signed short i16temp;
	}uiontemp;

	//模块信息节点
	if((TopwayRegAddr >= 0x00084000) && (TopwayRegAddr <= 0x840FF))
	{
		u8NodeNo = ((TopwayRegAddr - 0x00084000) / 0x10);
		u8SigNo = ((TopwayRegAddr - 0x00084000) % 0x10);

		if(u8NodeNo >=  mRECTNUM) //暂时支持16各模块
		{
			return u16Value;
		}


		switch(u8SigNo)
		{
		case 0x00:	//模块状态
			if(gs_CANComm.RectData[u8NodeNo].bIsExisted == FALSE)
			{
				u16Value = 2;  //不存在
			}
			else if(gs_CANComm.RectData[u8NodeNo].bCommFail == TRUE)
			{
				u16Value = 1;		//通信断
			}
			else
			{
				if(((gs_CANComm.RectData[u8NodeNo].bStatCode[2] & RECT_STAT_CODE_2_ALM_BITs) != 0)
					|| ((gs_CANComm.RectData[u8NodeNo].bStatCode[1] & RECT_STAT_CODE_1_ALM_BITs) != 0)
					|| ((gs_CANComm.RectData[u8NodeNo].bStatCode[0] & RECT_STAT_CODE_0_ALM_BITs) != 0)
					)
				{
					u16Value = 3;   //告警
				}
				else
				{
					u16Value = 0;
				}
			}
			break;
		case 0x02:	//模块组号
			if(gs_CANComm.RectData[u8NodeNo].bIsExisted == TRUE)
			{
				if(gEvChargeInfo.u8IsRingEnabled == TRUE)
				{
					u16Value = gs_CANComm.RectData[u8NodeNo].nBelongedGrp - gs_CANComm.byGrpIdx[GRP_A]  + 1;
				}
				else
				{
					u16Value = gs_CANComm.RectData[u8NodeNo].nBelongedGrp;
				}
				if(u16Value > 2)
				{
					u16Value = 0;
				}
			}
			break;
		case 0x04:	//模块温度
			if(gs_CANComm.RectData[u8NodeNo].bIsExisted == TRUE)
			{
				uiontemp.i16temp = (signed short)gs_CANComm.RectData[u8NodeNo].fRealTime_Temp;
				u16Value = uiontemp.u16temp;
			}
			break;
		case 0x06:	//模块输出电压	
			if(gs_CANComm.RectData[u8NodeNo].bIsExisted == TRUE)
			{
				u16Value = (unsigned short)gs_CANComm.RectData[u8NodeNo].fRealTime_Volt;
			}
			break;
		case 0x08:	//模块输出电流
			if(gs_CANComm.RectData[u8NodeNo].bIsExisted == TRUE)
			{
				u16Value = (unsigned short)(gs_CANComm.RectData[u8NodeNo].fRealTime_Curr*10);
			}
			break;
		case 0x0A:	//模块状态码1
			if(gs_CANComm.RectData[u8NodeNo].bIsExisted == TRUE)
			{
				u16Value = (unsigned short)(gs_CANComm.RectData[u8NodeNo].bStatCode[0]);
			}
			break;
		case 0x0C:	//模块状态码2
			if(gs_CANComm.RectData[u8NodeNo].bIsExisted == TRUE)
			{
				u16Value = (unsigned short)(gs_CANComm.RectData[u8NodeNo].bStatCode[1]);
			}
			break;
		case 0x0E:	//模块状态码3
			if(gs_CANComm.RectData[u8NodeNo].bIsExisted == TRUE)
			{
				u16Value = (unsigned short)(gs_CANComm.RectData[u8NodeNo].bStatCode[2]);
			}
			break;
		default:
			break;
		}

		
	}

	return u16Value;
}

//static struct tm  s_tmNow;
unsigned short  u16TopwayGet16bitsSignal(unsigned long TopwayRegAddr)
{
	__XXX_UNION_VALUE unTempVal;
	INT32 iTempVal = 0;
	void *PEInfo;
	static struct tm  s_tmNow;
	//void *PEInfo_2;
	//UNUSED(RegAddr);
	UINT8 u8temp, u8Index;
	UINT16 u16temp;
	UINT16 u16Value = 0;
	UNUSED(u16Value);
	union
	{
		unsigned short u16Value;
		short i16Value;
	}union_16bit_value;


	//在DHCP使能情况下，上报的IP、MASK/GATEWAY要用DHCP动态所获取的值
	if((TopwayRegAddr >= TOPWAY_16BIT_IP_ADDR_RANGE_START) && (TopwayRegAddr <= TOPWAY_16BIT_IP_ADDR_RANGE_END))
	{
		ExGetSigInfo(E_TYPE_SYS, ID_NET_DHCP, &unTempVal, NULL, BY_E2PROM);
		if (unTempVal.chtemp[0] == 1)
		{			
			return u16TopwayGetDHCPNetInfo(TopwayRegAddr);
		}
	}

	//获取参数设置
	if( ((TopwayRegAddr >= TOPWAY_16BIT_SYS_PARA_ADDR_RANGE_START) && (TopwayRegAddr <= TOPWAY_16BIT_SYS_PARA_ADDR_RANGE_END))
		||((TopwayRegAddr >= TOPWAY_16BIT_SYS_PARA_2_ADDR_RANGE_START) && (TopwayRegAddr <= TOPWAY_16BIT_SYS_PARA_2_ADDR_RANGE_END))
		|| ((TopwayRegAddr >= TOPWAY_16BIT_GUN_A_PARA_ADDR_RANGE_START) && (TopwayRegAddr <= TOPWAY_16BIT_GUN_A_PARA_ADDR_RANGE_END))
		|| ((TopwayRegAddr >= TOPWAY_16BIT_GUN_B_PARA_ADDR_RANGE_START) && (TopwayRegAddr <= TOPWAY_16BIT_GUN_B_PARA_ADDR_RANGE_END)) 
		|| ((TopwayRegAddr >= TOPWAY_16BIT_FEE_PARA_ADDR_RANGE_START) && (TopwayRegAddr <= TOPWAY_16BIT_FEE_PARA_ADDR_RANGE_END))
		|| ((TopwayRegAddr >= TOPWAY_16BIT_ADJUST_PARA_ADDR_RANGE_START) && (TopwayRegAddr <= TOPWAY_16BIT_ADJUST_PARA_ADDR_RANGE_END)))
	{
		return u16TopwayGet16BitCfgSignal(TopwayRegAddr);
	}

	//A枪超时事件 地址范围
	if((TopwayRegAddr >= TOPWAY_16BIT_GUN_A_OT_EVENT_ADDR_RANGE_START) && (TopwayRegAddr <= TOPWAY_16BIT_GUN_A_OT_EVENT_ADDR_RANGE_END))		
	{
		u8temp = ((TopwayRegAddr - TOPWAY_16BIT_GUN_A_OT_EVENT_ADDR_RANGE_START)/ 2);

		if((gs_ChargeRecordMng[GUN_NO_A].ucChargeRecordNum == 0)
			|| (u8temp >= gs_ChargeRecordMng[GUN_NO_A].ucChargeRecordNum))
		{
			return 0;
		}		
		else
		{
			u8Index = GetChargeRecordIndex(GUN_NO_A, u8temp);
			u16Value = gs_ChargeRecordMng[GUN_NO_A].ChargeRecord[u8Index].u16EndReason;
			return u16Value;
		}		
	}
	//B枪超时事件 地址范围
	if((TopwayRegAddr >= TOPWAY_16BIT_GUN_B_OT_EVENT_ADDR_RANGE_START) && (TopwayRegAddr <= TOPWAY_16BIT_GUN_B_OT_EVENT_ADDR_RANGE_END))		
	{
		u8temp = ((TopwayRegAddr - TOPWAY_16BIT_GUN_B_OT_EVENT_ADDR_RANGE_START)/ 2);

		if((gs_ChargeRecordMng[GUN_NO_B].ucChargeRecordNum == 0)
			|| (u8temp >= gs_ChargeRecordMng[GUN_NO_B].ucChargeRecordNum))
		{
			return 0;
		}		
		else
		{
			u8Index = GetChargeRecordIndex(GUN_NO_B, u8temp);
			u16Value = gs_ChargeRecordMng[GUN_NO_B].ChargeRecord[u8Index].u16EndReason;
			return u16Value;
		}		
	}

	//获取环网状态信息
	if( (TopwayRegAddr >= TOPWAY_16BIT_RING_ADDR_RANGE_START) && (TopwayRegAddr <= TOPWAY_16BIT_RING_ADDR_RANGE_END))		
	{
		return u16TopwayGet16BitRingSignal(TopwayRegAddr);
	}

	//获取模块状态信息
	if( (TopwayRegAddr >= TOPWAY_16BIT_RECT_ADDR_RANGE_START) && (TopwayRegAddr <= TOPWAY_16BIT_RECT_ADDR_RANGE_END))		
	{
		return u16TopwayGet16BitRectSignal(TopwayRegAddr);
	}

	

	switch (TopwayRegAddr)
	{
		case TOPWAY_16BIT_ADDR_GUN_SELECT:
			if(gEvChargeInfo.u8IsSingleGunMode == FALSE) //双枪模式
			{
				if(gEvChargeInfo.u8GunSelect < 3)
				{
					u16Value = gEvChargeInfo.u8GunSelect;
				}
			}
			break;

		case TOPWAY_16BIT_ADDR_CHG_MODE_SELECT:// 
			/*if(gEvChargeInfo.u8GunSelect == 1)
			{
				u16Value = gEvChargeInfo.u8ChargeMode[GUN_NO_A];
			}
			else if(gEvChargeInfo.u8GunSelect == 2)
			{
				u16Value = gEvChargeInfo.u8ChargeMode[GUN_NO_B];
			}*/
			u16Value = gTempChargeArgs.u8ChargeMode;
		break;

		case TOPWAY_16BIT_ADDR_SET_CHG_TIME:// = 0x00080008,			//充电模式-按时间 设定时间值
			u16Value = (UINT16)gTempChargeArgs.fTimeArgs;
			break;
		case TOPWAY_16BIT_ADDR_SET_CHG_ENERGY:// = 0x0008000A,			//充电模式-按电量 设定电量值
			u16Value = (UINT16)gTempChargeArgs.fEnergeArgs;
			break;
		//case TOPWAY_16BIT_ADDR_SET_CHG_MONEY: //= 0x0008000C,			//充电模式-按金额 设定金额值
		//	u16Value = (UINT16)(gTempChargeArgs.fMoney);
		//	break;
		case TOPWAY_16BIT_ADDR_SET_CHG_SOC:// = 0x0008000E,				//充电模式-按SOC 设定SOC值
			u16Value = (UINT16)(gTempChargeArgs.fSOCArgs);
			break;
		case TOPWAY_16BIT_ADDR_DISP_CARD_MONEY:
			u16Value = gs_DisplayCtrl.u8IsDispCardLeaveMoney;
			break;

//卡联网 验证状态提示界面  0x00080020~0x0008002F
		case TOPWAY_16BIT_ADDR_CARD_CERTIFY_STAT:  // 		//验证状态
			u16Value = gBrushInfo.ucCardInfoConfirmResult;
			break;

		case TOPWAY_16BIT_ADDR_CARD_CERTIFY_TIMEOUT:  //	//验证倒计时
			if(gBrushInfo.u8AccountRequestStep == ACCOUNT_REQUEST_STEP_1)
			{
				if(gBrushInfo.u8BrushWaitHostConfirmTimeout < BRUSH_WAIT_HOST_CONFIRM_STEP_1_TIME)
				{
					u16Value = BRUSH_WAIT_HOST_CONFIRM_STEP_1_TIME - gBrushInfo.u8BrushWaitHostConfirmTimeout;
				}
			}
			else if(gBrushInfo.u8AccountRequestStep == ACCOUNT_REQUEST_STEP_2)
			{
				if(gBrushInfo.u8BrushWaitHostConfirmTimeout < BRUSH_WAIT_HOST_CONFIRM_STEP_2_TIME)
				{
					u16Value = BRUSH_WAIT_HOST_CONFIRM_STEP_2_TIME - gBrushInfo.u8BrushWaitHostConfirmTimeout;
				}
			}
			else if(gBrushInfo.u8AccountRequestStep == ACCOUNT_REQUEST_STEP_4)
			{
				if(gBrushInfo.u8BrushWaitHostConfirmTimeout < BRUSH_WAIT_HOST_CONFIRM_STEP_4_TIME)
				{
					u16Value = BRUSH_WAIT_HOST_CONFIRM_STEP_4_TIME - gBrushInfo.u8BrushWaitHostConfirmTimeout;
				}
			}
			break;
		//VIN联网 验证状态提示界面  0x00080028~0x0008002F
		case TOPWAY_16BIT_ADDR_VIN_CERTIFY_STAT:  // 		//验证状态
			u16Value = gEvChargeInfo.u8VinVerifyStat;
			break;

		case TOPWAY_16BIT_ADDR_VIN_CERTIFY_TIMEOUT:  //	//验证倒计时
			//if(gEvChargeInfo.u8VinWaitHostConfirmTimeout < BRUSH_WAIT_HOST_CONFIRM_STEP_1_TIME)
			{
				u16Value = gEvChargeInfo.u8VinWaitHostConfirmTimeout;
			}
			break;
		case TOPWAY_16BIT_ADDR_VIN_CERTIFY_GUN_SEL:  // 		//验证状态
			if(gs_DisplayCtrl.u8GunDispStat[GUN_NO_A] == GUN_DISP_STAT_VinCheckAndWaitHostConfirm)
			{		
				u16Value = 1;
			}
			else if(gs_DisplayCtrl.u8GunDispStat[GUN_NO_B] == GUN_DISP_STAT_VinCheckAndWaitHostConfirm)
			{		
				u16Value = 2;
			}
			break;
/********************************************************************************************************************/
/************************************************信号类型分界********************************************************/
/********************************************************************************************************************/
//状态信息 需要经常刷新0x00080100~0x000801EF
		case TOPWAY_16BIT_ADDR_SYSTEM_ALARM_STAT: // = 0x00080100,		//系统告警状态
			if((gEvChargeInfo.u8SysAlm == TRUE) || (gEvChargeInfo.u8Gun_Alm[GUN_NO_A] == TRUE) || (gEvChargeInfo.u8Gun_Alm[GUN_NO_B] == TRUE)
				|| (gEvChargeInfo.u8GunOverTemAlm[GUN_NO_A] == TRUE)
				|| (gEvChargeInfo.u8GunOverTemAlm[GUN_NO_B] == TRUE)
				|| (gs_CANComm.GrpData[GRP_A].bIsAnyRectAlarm == TRUE)
				|| (gs_CANComm.GrpData[GRP_B].bIsAnyRectAlarm == TRUE)
				)
			{
				u16Value = 1;
			}
			else if(gEvChargeInfo.u8IsRingEnabled == TRUE)
			{
				u16Value = (UINT16)(g_pRing_A->bSelfIDConflict || g_pRing_B->bSelfIDConflict);
			}
			break;

		case TOPWAY_16BIT_ADDR_SYSTEM_NET_STAT:// = 0x00080102,			//系统后台网络连接状态
			break;

		case TOPWAY_16BIT_ADDR_SYSTEM_TIME_Y:// = 0x00080104,			//系统时间 年
			gRTCData.fGetLocalTime(&s_tmNow);
			u16Value = s_tmNow.tm_year;
			break;

		case TOPWAY_16BIT_ADDR_SYSTEM_TIME_MON:// = 0x00080106,			//系统时间 月
			u16Value = s_tmNow.tm_mon;
			break;

		case TOPWAY_16BIT_ADDR_SYSTEM_TIME_D:// = 0x00080108,			//系统时间 日
			u16Value = s_tmNow.tm_mday;
			break;

		case TOPWAY_16BIT_ADDR_SYSTEM_TIME_H:// = 0x0008010A,			//系统时间 时
			u16Value = s_tmNow.tm_hour;
			break;

		case TOPWAY_16BIT_ADDR_SYSTEM_TIME_MIN:// = 0x0008010C,			//系统时间 分
			u16Value = s_tmNow.tm_min;
			break;

		case TOPWAY_16BIT_ADDR_SYSTEM_TIME_S:// = 0x0008010E,			//系统时间 秒
			u16Value = s_tmNow.tm_sec;
			break;

		case TOPWAY_16BIT_ADDR_SYSTEM_WaitSpearTimeout:   //等待枪插入 超时 计时器 s
			if(gs_DisplayCtrl.u8CurrPageNo == TOPWAY_SCREEM_PAGE_NOTICE_PLUGIN_SPEAR)
			{
				u16Value = gs_DisplayCtrl.u8WaitSpearOkTimeout;
			}
			else
			{
				u16Value = WAIT_SPEAR_OK_TIME_MAX;
			}
			break;
		case TOPWAY_16BIT_ADDR_SYSTEM_WaitChgModeSelTimeout:   //等待 超时 计时器 s
			if((gs_DisplayCtrl.u8CurrPageNo >= TOPWAY_SCREEM_PAGE_CHGMODE_SEL_AUTO)
				&& (gs_DisplayCtrl.u8CurrPageNo <= TOPWAY_SCREEM_PAGE_CHGMODE_SEL_SOC))
			{
				u16Value = gs_DisplayCtrl.u8WaitChgModeSelTimeout;
			}
			else
			{
				u16Value = WAIT_CHG_MODE_SEL_TIME_MAX;
			}
			break;
		case TOPWAY_16BIT_ADDR_SYSTEM_EnterAdjustPage_En:  //允许进入校准界面
			if((gs_DisplayCtrl.u8GunDispStat[0] == GUN_DISP_STAT_Standby) 
				&& (gs_DisplayCtrl.u8GunDispStat[1] == GUN_DISP_STAT_Standby))
			{
				u16Value = 1;
			}
			break;
		case TOPWAY_16BIT_ADDR_SYSTEM_QuitAdjustPage_En:  //允许退出校准界面
			if((gEvChargeInfo.u8TestMode[GUN_NO_A] == FALSE) 
				&& (gEvChargeInfo.u8TestMode[GUN_NO_B] == FALSE))
			{
				u16Value = 1;
			}
			break;
		case TOPWAY_16BIT_ADDR_SYSTEM_IS_SINGLE_GUN_MODE:  //是否单枪工作模式
			if(gEvChargeInfo.u8IsSingleGunMode == TRUE) //单枪模式
			{
				u16Value = 1;
			}
			break;
			
			

/********************************************************************************************************************/
/************************************************信号类型分界********************************************************/
/********************************************************************************************************************/
//密码登录
		case TOPWAY_16BIT_ADDR_PASSWORD_INPUT_USER_LEVEL: //= 0x000801F0,			//充电模式-按金额 设定金额值
			u16Value = gs_DisplayCtrl.u8UserLevel;
			break;
		case TOPWAY_16BIT_ADDR_PASSWORD_INPUT_IS_OK:// = 0x000801F2,				//充电模式-按SOC 设定SOC值
			u16Value = gs_DisplayCtrl.u8PasswordIsOk;
			break;
		case TOPWAY_16BIT_ADDR_STOP_PASSWORD_INPUT_IS_OK:
			u16Value = gs_DisplayCtrl.u8ManualStopChgPasswordIsOk;
			break;
/********************************************************************************************************************/
/************************************************信号类型分界********************************************************/
/********************************************************************************************************************/
//关于 
		case TOPWAY_16BIT_ADDR_ABOUT_SOFTWARE_VER: //= 0x00080A00,					//关于 软件版本
		case TOPWAY_16BIT_ADDR_ABOUT_CONFIG_VER:// = 0x00080A02,					//关于 配置版本
			u16Value = u16TopwayGet16BitCfgSignal(TopwayRegAddr);
			break;

		case TOPWAY_16BIT_ADDR_ABOUT_POWER_TIMES:
			u16Value = (UINT16)gEvChargeInfo.u32PowerOnTimes;
			break;
		case TOPWAY_16BIT_ADDR_RESET_REASON1:
			u16Value = (UINT16)gs_E2PROM.ResetReasonRecord[0];
			break;
		case TOPWAY_16BIT_ADDR_RESET_REASON2:
			u16Value = (UINT16)gs_E2PROM.ResetReasonRecord[1];
			break;
		case TOPWAY_16BIT_ADDR_RESET_REASON3:
			u16Value = (UINT16)gs_E2PROM.ResetReasonRecord[2];
			break;

/********************************************************************************************************************/
/************************************************信号类型分界********************************************************/
/********************************************************************************************************************/
		//告警 数据 0x00080D00~0x0080DFF
		case TOPWAY_16BIT_ADDR_ALARM_SYS_AC_HIGH:// = 0x00080D00,		//告警信息 交流过压
			PEInfo = GetgEquipInfo(E_RECT_INFO);
			u16Value = (UINT16)(((CANCommData_TypeDef*)PEInfo)->u8IsACOver);
			if ((((CANCommData_TypeDef*)PEInfo)->u8IsAllCommFail))
			{
				u16Value = 0;
			}
			break;

		case TOPWAY_16BIT_ADDR_ALARM_SYS_AC_LOW:// = 0x00080D02,		//告警信息 交流欠压
			PEInfo = GetgEquipInfo(E_RECT_INFO);
			u16Value = (UINT16)(((CANCommData_TypeDef*)PEInfo)->u8IsACUnder);
			if ((((CANCommData_TypeDef*)PEInfo)->u8IsAllCommFail))
			{
				u16Value = 0;
			}
			break;

		case TOPWAY_16BIT_ADDR_ALARM_SYS_EPO:// = 0x00080D04,			//告警信息 EPO
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			u16Value = (UINT16)(((EV_CHARGE_INFO*)PEInfo)->u8EPOAlm);
			break;

		case TOPWAY_16BIT_ADDR_ALARM_SYS_SPD:// = 0x00080D06,			//告警信息 SPD
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			u16Value = (UINT16)(((EV_CHARGE_INFO*)PEInfo)->u8SPDAlm);
			break;

		case TOPWAY_16BIT_ADDR_ALARM_SYS_NET_FAIL:// = 0x00080D08,		//告警信息 网络连接异常
			if(gEvChargeInfo.u8NET_Mask == FALSE)
			{
				PEInfo = GetgEquipInfo(E_TYPE_SYS);
				u16Value = (UINT16)(((EV_CHARGE_INFO*)PEInfo)->u8NetCommAlm);
			}
			break;

		case TOPWAY_16BIT_ADDR_ALARM_SYS_NOT_LOGIN:// = 0x00080D0A,		//告警信息 后台未登录注册
			/*if(gEvChargeInfo.u8NET_Mask == FALSE)
			{
				PEInfo = GetgEquipInfo(E_TYPE_SYS);
				u16Value = (UINT16)(((EV_CHARGE_INFO*)PEInfo)->u8TelaidianHostCommAlm);
			}*/
			break;

		case TOPWAY_16BIT_ADDR_ALARM_SYS_CARDREADER_FAIL:// = 0x00080D0C,//告警信息 刷卡机故障
			PEInfo = GetgEquipInfo(E_TYPE_BRUSH);
			u16Value = (UINT16)(((BRUSH_INFO*)PEInfo)->uBrushCommAlm);
			break;

		case TOPWAY_16BIT_ADDR_ALARM_SYS_DOOR_OPEN:// = 0x00080D0E,		//告警信息 门禁
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			u16Value = (UINT16)(((EV_CHARGE_INFO*)PEInfo)->u8DoorAlm);
			break;
		case TOPWAY_16BIT_ADDR_ALARM_SYS_RING_ID_CONFLICT:
			if(gEvChargeInfo.u8IsRingEnabled == TRUE)
			{
				u16Value = (UINT16)(g_pRing_A->bSelfIDConflict || g_pRing_B->bSelfIDConflict);
			}
			break;
		case TOPWAY_16BIT_ADDR_ALARM_SYS_RING_CFG_ERROR:
			if(gEvChargeInfo.u8IsRingEnabled == TRUE)
			{
				if((gs_CANComm.bIsRingEnabled == FALSE) || (g_RingAllInfo.bIsRingCfgErr == TRUE))
				{
					u16Value = 1;
				}
			}
			break;

		case TOPWAY_16BIT_ADDR_ALARM_GUN_A_INSUL_FAIL:// = 0x00080D20,	//告警信息 A枪绝缘告警
			if((gEvChargeInfo.u8IsSingleGunMode == TRUE)
				&&(gIMIU_Info1.u8InsltCheckByVolt == INSLT_CHK_Mode_LeakageCurr))
			{
				u16Value = (UINT16)gEvChargeInfo.u8InsulationAlm;
			}
			else
			{
				PEInfo = GetgEquipInfo(E_TYPE_IMIU1);
				u16Value = (UINT16)(((stIMIU_Info*)PEInfo)->u8JYMAlmStat[0]);
			}
			break;

		case TOPWAY_16BIT_ADDR_ALARM_GUN_A_IMIU_FAIL:// = 0x00080D22,	//告警信息 A枪IMIU告警
			PEInfo = GetgEquipInfo(E_TYPE_IMIU1);
			u16Value = (UINT16)(((stIMIU_Info*)PEInfo)->u8InsltCommAlm[0]);
			break;

		case TOPWAY_16BIT_ADDR_ALARM_GUN_A_METER_FAIL:// = 0x00080D24,	//告警信息 A枪电表告警
			PEInfo = GetgEquipInfo(E_TYPE_WH1);
			u16Value = (UINT16)(((stWHInfo*)PEInfo)->u8WHCommAlm);
			break;

		case TOPWAY_16BIT_ADDR_ALARM_GUN_A_CC1_FAIL:// = 0x00080D26,	//告警信息 A枪CC1告警
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			u16Value = (UINT16)(((EV_CHARGE_INFO*)PEInfo)->u8EV_SpearPst[GUN_NO_A]);
			if (u16Value != SPEAR_ON_LINE)
			{
				u16Value = 1;
			}
			else
			{
				u16Value = 0;
			}
			break;

		case TOPWAY_16BIT_ADDR_ALARM_GUN_A_VOLT_OVER:// = 0x00080D28,	//告警信息 A枪母排过压
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->u8_Bus_Over_Alm);
			break;

		case TOPWAY_16BIT_ADDR_ALARM_GUN_A_CELL_VOLT_OVER:// = 0x00080D2A,//告警信息 A枪单体过压
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			if(((stBMS_INFO*)PEInfo)->u8_Cell_Over_Alm > 0)
			{
				u16Value = 1;
			}
			break;

		case TOPWAY_16BIT_ADDR_ALARM_GUN_A_CURR_OVER:// = 0x00080D2C,	//告警信息 A枪过流
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->u8_OverCurr_Alm);
			break;

		case TOPWAY_16BIT_ADDR_ALARM_GUN_A_POLARITY_FAIL:// = 0x00080D2E,//告警信息 A枪极性告警
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->u8Polarity_Alm);
			break;

		case TOPWAY_16BIT_ADDR_ALARM_GUN_A_NO_RECT:// = 0x00080D30,		//告警信息 A枪无整流模块
			PEInfo = GetgEquipInfo(E_RECT_INFO);
			if ((((CANCommData_TypeDef*)PEInfo)->GrpData[GRP_A].u8IsNoNormalRect))
			{
				u16Value = 1;
			}
			else
			{
				u16Value = 0;
			}
			break;
		case TOPWAY_16BIT_ADDR_ALARM_GUN_A_GUN_OVERTEM:// = 0x00080D32,		//告警信息 A枪过温
			u16Value = gEvChargeInfo.u8GunOverTemAlm[GUN_NO_A];	
			break;
		case TOPWAY_16BIT_ADDR_ALARM_GUN_A_GUN_RectAlm:
			u16Value = gs_CANComm.GrpData[GRP_A].bIsAnyRectAlarm;	
			break;
		case TOPWAY_16BIT_ADDR_ALARM_GUN_A_GUN_EarthFalt:
			PEInfo = GetgEquipInfo(E_TYPE_IMIU1);
			u16Value = (UINT16)(((stIMIU_Info*)PEInfo)->u8EarthFalt[0]);
			break;


		case TOPWAY_16BIT_ADDR_ALARM_GUN_B_INSUL_FAIL:// = 0x00080D40,	//告警信息 B枪绝缘告警
			PEInfo = GetgEquipInfo(E_TYPE_IMIU2);
			u16Value = (UINT16)(((stIMIU_Info*)PEInfo)->u8JYMAlmStat[0]);
			break;

		case TOPWAY_16BIT_ADDR_ALARM_GUN_B_IMIU_FAIL:// = 0x00080D42,	//告警信息 B枪IMIU告警
			PEInfo = GetgEquipInfo(E_TYPE_IMIU2);
			u16Value = (UINT16)(((stIMIU_Info*)PEInfo)->u8InsltCommAlm[0]);
			break;

		case TOPWAY_16BIT_ADDR_ALARM_GUN_B_METER_FAIL:// = 0x00080D44,	//告警信息 B枪电表告警
			PEInfo = GetgEquipInfo(E_TYPE_WH2);
			u16Value = (UINT16)(((stWHInfo*)PEInfo)->u8WHCommAlm);
			break;

		case TOPWAY_16BIT_ADDR_ALARM_GUN_B_CC1_FAIL:// = 0x00080D46,	//告警信息 B枪CC1告警
			//双枪模式才告警
			if(gEvChargeInfo.u8IsSingleGunMode == FALSE)
			{			
				PEInfo = GetgEquipInfo(E_TYPE_SYS);
				u16Value = (UINT16)(((EV_CHARGE_INFO*)PEInfo)->u8EV_SpearPst[GUN_NO_B]);
				if (u16Value != SPEAR_ON_LINE)
				{
					u16Value = 1;
				}
				else
				{
					u16Value = 0;
				}
			}
			
			break;

		case TOPWAY_16BIT_ADDR_ALARM_GUN_B_VOLT_OVER:// = 0x00080D48,	//告警信息 B枪母排过压
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->u8_Bus_Over_Alm);
			break;

		case TOPWAY_16BIT_ADDR_ALARM_GUN_B_CELL_VOLT_OVER:// = 0x00080D4A,//告警信息 B枪单体过压
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			if(((stBMS_INFO*)PEInfo)->u8_Cell_Over_Alm > 0)
			{
				u16Value = 1;
			}
			break;

		case TOPWAY_16BIT_ADDR_ALARM_GUN_B_CURR_OVER:// = 0x00080D4C,	//告警信息 B枪过流
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->u8_OverCurr_Alm);
			break;

		case TOPWAY_16BIT_ADDR_ALARM_GUN_B_POLARITY_FAIL:// = 0x00080D4E,//告警信息 B枪极性告警
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->u8Polarity_Alm);
			break;

		case TOPWAY_16BIT_ADDR_ALARM_GUN_B_NO_RECT:// = 0x00080D50,		//告警信息 B枪无整流模块
			PEInfo = GetgEquipInfo(E_RECT_INFO);
			if ((((CANCommData_TypeDef*)PEInfo)->GrpData[GRP_B].u8IsNoNormalRect))
			{
				u16Value = 1;
			}
			else
			{
				u16Value = 0;
			}
			break;
		case TOPWAY_16BIT_ADDR_ALARM_GUN_B_GUN_OVERTEM:// = 0x00080D52,		//告警信息 B枪过温
			u16Value = gEvChargeInfo.u8GunOverTemAlm[GUN_NO_B];	
			break;
		case TOPWAY_16BIT_ADDR_ALARM_GUN_B_GUN_RectAlm:
			u16Value = gs_CANComm.GrpData[GRP_B].bIsAnyRectAlarm;	
			break;
		case TOPWAY_16BIT_ADDR_ALARM_GUN_B_GUN_EarthFalt:
			PEInfo = GetgEquipInfo(E_TYPE_IMIU2);
			u16Value = (UINT16)(((stIMIU_Info*)PEInfo)->u8EarthFalt[0]);
			break;

/********************************************************************************************************************/
/************************************************信号类型分界********************************************************/
/********************************************************************************************************************/

		//A枪充电页面信息 0x00081100~0x008112F	
		case TOPWAY_16BIT_ADDR_CHG_GUN_A_CHG_MODE:// = 0x00081100,		//A枪 启动模式 0-自动充满 1-按时间 2-按电量 3-按金额 4-按SOC
			u16Value = gEvChargeInfo.u8ChargeMode[GUN_NO_A];
			break;

		case TOPWAY_16BIT_ADDR_CHG_GUN_A_TIME:// = 0x00081102,			//A枪 已充时间
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			u16Value = (UINT16)(((EV_CHARGE_INFO*)PEInfo)->fBMS_ChargeTime[GUN_NO_A]);
			break;						

		case TOPWAY_16BIT_ADDR_CHG_GUN_A_ENERGY:// = 0x00081104,		//A枪 启动电量
			u16Value = (UINT16)(gEvChargeInfo.fTotalOutEnergy[0]*100); 			
			break;	

		case TOPWAY_16BIT_ADDR_CHG_GUN_A_MONEY:// = 0x00081106,			//A枪 已充金额			
			u16Value = (UINT16)(gEvChargeInfo.fCostMoney[0] *100);
			break;

		case TOPWAY_16BIT_ADDR_CHG_GUN_A_REMAIN_TIME:// = 0x00081108,	//A枪 剩余时间
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->u16BCS_LeaveTime);
			break;

		case TOPWAY_16BIT_ADDR_CHG_GUN_A_REQ_VOLT:// = 0x0008110A,		//A枪 需求电压 
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBMSRequireVolt * 10);
			break;		

		case TOPWAY_16BIT_ADDR_CHG_GUN_A_REQ_CURR:// = 0x0008110C,		//A枪 需求电流
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBMSRequireCurr * 10);
			break;					

		case TOPWAY_16BIT_ADDR_CHG_GUN_A_OUT_VOLT: // = 0x0008110E,		//A枪 输出电压
			PEInfo = GetgEquipInfo(E_RECT_INFO);
			u16Value = (UINT16)(((CANCommData_TypeDef*)PEInfo)->GrpData[GRP_A].fOutVolt * 10);
			break;

		case TOPWAY_16BIT_ADDR_CHG_GUN_A_OUT_CURR:// = 0x00081110,		//A枪 输出电流
			//电表正常时使用电表读数
			/*if((gWH_Info[GUN_NO_A].u8WH_ALM_Mask == FALSE) && (gWH_Info[GUN_NO_A].u8WHCommAlm == FALSE))
			{
				u16Value = (UINT16)(gWH_Info[GUN_NO_A].fWH_A_Curr * 10);
			}
			else*/
			if(gs_CANComm.bIsRingEnabled == TRUE)
			{
				u16Value = (UINT16)(g_pRing_A->master.fTotalOutCurr * 10);
			}
			else 
			{
				PEInfo = GetgEquipInfo(E_RECT_INFO);
				u16Value = (UINT16)(((CANCommData_TypeDef*)PEInfo)->GrpData[GRP_A].fOutCurr * 10);
				if (gEvChargeInfo.RectOwner[GUN_NO_A] == GRP_B)
				{
					u16Value = 0;
				}
				if (gEvChargeInfo.RectOwner[GUN_NO_B] == GRP_A)
				{
					u16Value += (UINT16)(((CANCommData_TypeDef*)PEInfo)->GrpData[GRP_B].fOutCurr * 10);
				}
			}		
			break;	

		case TOPWAY_16BIT_ADDR_CHG_GUN_A_SOC:// = 0x00081112,			//A枪 SOC
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCS_SOC);
			break;		
		case TOPWAY_16BIT_ADDR_CHG_GUN_A_CHG_STATE:   //充电阶段提示
			if(gEvChargeInfo.u8_Charge_CMD[GUN_NO_A] == START_CHARGE_VAL)
			{
				if(gEvChargeInfo.RectOwner[GUN_NO_A] == GRP_B)
				{
					u16Value = 3;   //等待另侧释放
				}
				else if(gBms_1_CommInfo.i8_CMD_Phase == HANDSHAKE_SELF_CHECK)
				{
					u16Value = 0;  //自检
				}
				else if(((gBms_1_CommInfo.i8_CMD_Phase > HANDSHAKE_SELF_CHECK) && (gBms_1_CommInfo.i8_CMD_Phase < CHARGING_RCV_BCL_SEND_CCS))
					|| (gBms_1_CommInfo.i8_CMD_Phase == EV_CEM_XXXX))
				{
					u16Value = 1;  //配置
				}
				else if(gBms_1_CommInfo.i8_CMD_Phase == CHARGING_RCV_BCL_SEND_CCS)
				{
					if((gs_CANComm.bIsRingEnabled == TRUE)
						&& (g_pRing_A->master.nSlaveTotal > 0))
					{
						u16Value = 5;  //充电中且并机
					}
					else if(gEvChargeInfo.RectOwner[GUN_NO_B] == GRP_A)
					{
						u16Value = 5;  //充电中且并机
					}
					else
					{
						u16Value = 2;  //充电中
					}
				}
				else
				{
					u16Value = 4;  //停止
				}
			}
			else
			{
				u16Value = 4;  //停止
			}
			
			break;
                   case TOPWAY_16BIT_ADDR_CHG_GUN_A_SOC_ANIMATION:// = 0x00081112,			//A枪 SOC
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCS_SOC);
                        
            if(gBms_1_CommInfo.i8_CMD_Phase == CHARGING_RCV_BCL_SEND_CCS)
            {
                if(gs_DisplayCtrl.u8SocAnimationStep[0] == 0)
                {
                    u16Value += SOC_DISP_ANIMATION_STEP;
                    gs_DisplayCtrl.u8SocAnimationStep[0] = 1;
					if(u16Value >= 100)
					{
						gs_DisplayCtrl.u8SocAnimationStep[0] = 2;
					}
                }
                else if(gs_DisplayCtrl.u8SocAnimationStep[0] == 1)
                {
                    u16Value += (SOC_DISP_ANIMATION_STEP*2);
                    gs_DisplayCtrl.u8SocAnimationStep[0] = 2;
                }
                else
                {
                    gs_DisplayCtrl.u8SocAnimationStep[0] = 0;
                }
                if(u16Value > 100)
                {
                    u16Value = 100;
                }
            }
                          
			break;		

/********************************************************************************************************************/
/************************************************信号类型分界********************************************************/
/********************************************************************************************************************/
		//A枪详细信息页面 0x00081130~0x00811FF	
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_RECT_NUMBER:// = 0x00081130,	//A枪 整流模块个数
			PEInfo = GetgEquipInfo(E_RECT_INFO);
			u16Value = (UINT16)(((CANCommData_TypeDef*)PEInfo)->GrpData[GRP_A].nCommRectNum);
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_AC_VOLT_A:// = 0x00081132,		//A枪 AB线电压
			PEInfo = GetgEquipInfo(E_RECT_INFO);
			u16Value = (UINT16)(((CANCommData_TypeDef*)PEInfo)->RectData[0].fAB_Volt * 10);
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_AC_VOLT_B:// = 0x00081134,		//A枪 BC线电压
			PEInfo = GetgEquipInfo(E_RECT_INFO);
			u16Value = (UINT16)(((CANCommData_TypeDef*)PEInfo)->RectData[0].fBC_Volt * 10);
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_AC_VOLT_C:// = 0x00081136,		//A枪 CA线电压
			PEInfo = GetgEquipInfo(E_RECT_INFO);
			u16Value = (UINT16)(((CANCommData_TypeDef*)PEInfo)->RectData[0].fCA_Volt * 10);
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_CC1_VOLT:// = 0x00081138,		//A枪 CC1电压
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			u16Value = (UINT16)(((EV_CHARGE_INFO*)PEInfo)->fCC1_1VoltVal *10);
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_SYS_TEM:// = 0x0008113A,		//A枪 系统温度
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			if (((EV_CHARGE_INFO*)PEInfo)->fEV_InterTemp >= 0)
			{
				u16Value = (UINT16)(((EV_CHARGE_INFO*)PEInfo)->fEV_InterTemp *10);
			}
			else
			{
				iTempVal = ABS((int)(((EV_CHARGE_INFO*)PEInfo)->fEV_InterTemp * 10));
				iTempVal = (~(iTempVal-1))&0xffff;
				u16Value = iTempVal;
			}
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_ELOCK_STAT:// = 0x0008113C,	//A枪 电子锁状态
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->u8ElecLock_Alm);
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_METER_CURR:// = 0x0008113E,	//A枪 电表电流
			PEInfo = GetgEquipInfo(E_TYPE_WH1);
			u16Value = (UINT16)(((stWHInfo*)PEInfo)->fWH_A_Curr * 10);
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_BATT_TYPE:// = 0x00081140,		//A枪 电池类型
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->u8BRM_BattType);
			break;		

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_ALLOW_VOLT_MAX:// = 0x00081142,//A枪 最高允许电压
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCP_MaxChargeVolt * 10);
			break;								

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_ALLOW_TEM_MAX:// = 0x00081144,	//A枪 最高允许温度
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			if (((stBMS_INFO*)PEInfo)->fBCP_MaxAllowTemp >= 0)
			{
				u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCP_MaxAllowTemp *10);
			}
			else
			{
				iTempVal = ABS((int)(((stBMS_INFO*)PEInfo)->fBCP_MaxAllowTemp * 10));
				iTempVal = (~(iTempVal-1))&0xffff;
				u16Value = iTempVal;
			}
			break;						

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_ALLOW_CURR_MAX:// = 0x00081146,//A枪 最高允许电流
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCP_MaxAllowCurr * 10);
			break;					

        case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_ALLOW_CELL_V_MAX:// = 0x00081148,//A枪 最高允许单体电压
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCP_CellMaxVolt * 10);
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_BMS_RP_VOLT:// = 0x0008114A,	//A枪 BMS上报电压
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCS_MeasureVolt * 10);
			break;			

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_BMS_RP_CURR:// = 0x0008114C,	//A枪 BMS上报电流
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCS_MeasureCurr * 10);
			break;					

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_BATT_RATED_CAP:// = 0x0008114E,	//A枪 额定容量
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->u8BRM_RatedCAP * 10);
			break;			

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_BMS_RP_MAX_CELL_V:// = 0x00081150,	//A枪 BMS上报最高单体电压
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCS_MaxCellVolt * 10);
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_RES_P2PE:
			u16Value = (UINT16)(gIMIU_Info1.fJYMP2gResist[0] *10);
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_RES_N2PE:
			u16Value = (UINT16)(gIMIU_Info1.fJYMN2gResist[0] *10);
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_IMIU_VOLT:
			u16Value = (UINT16)(gIMIU_Info1.fJYMVolt[0] *10);
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_BATT_VOLT:
			u16Value = (UINT16)(gEvChargeInfo.fEV_BattVolt_1 *10);
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_BATT_MAX_TEMP:
			union_16bit_value.i16Value = (short)gEVBms_1_Info.fBSM_MaxBattTemp;
			u16Value = union_16bit_value.u16Value;
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_BATT_MIN_TEMP:
			union_16bit_value.i16Value = (short)gEVBms_1_Info.fBSM_MinBattTemp;
			u16Value = union_16bit_value.u16Value;
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_MAX_OUT_CURR:
			union_16bit_value.i16Value = (short)gs_CANComm.GrpData[GRP_A].fMax_OutCurr;
			u16Value = union_16bit_value.u16Value;
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_MAX_OUT_VOLT:
			union_16bit_value.i16Value = (short)gs_CANComm.GrpData[GRP_A].fMax_OutVolt;
			u16Value = union_16bit_value.u16Value;
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_RATE_OUT_PWR:
			union_16bit_value.i16Value = (short)gs_CANComm.GrpData[GRP_A].fRatedPower;
			u16Value = union_16bit_value.u16Value;
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_MIN_OUT_VOLT:
			union_16bit_value.i16Value = (short)gs_CANComm.GrpData[GRP_A].fMin_OutVolt;
			u16Value = union_16bit_value.u16Value;
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_CHG_CTRL_CRUU:
			u16Value = (unsigned short)(gEvChargeInfo.fNowRectCtrlOutCurrent[GUN_NO_A]*10);
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_BCP_BATTVOLT:
			u16Value = (unsigned short)(gEVBms_1_Info.fBCP_CurrBattVolt*10);
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_A_BMS_VER:
			if (gEvChargeInfo.u8Is_PUTIAN_V15[GUN_NO_A] == IS_PUTIAN_BMS)
			{
				u16Value = 2;
			}
			else
			{
				u16Value = (UINT16)gEVBms_1_Info.u8BMSVersion;
			}
			break;

/********************************************************************************************************************/
/************************************************信号类型分界********************************************************/
/********************************************************************************************************************/

			//B枪充电页面信息 0x00082100~0x008212F	
		case TOPWAY_16BIT_ADDR_CHG_GUN_B_CHG_MODE:// = 0x00081100,		//B枪 启动模式 0-自动充满 1-按时间 2-按电量 3-按金额 4-按SOC
			u16Value = gEvChargeInfo.u8ChargeMode[GUN_NO_B];
			break;

		case TOPWAY_16BIT_ADDR_CHG_GUN_B_TIME:// = 0x00081102,			//B枪 已充时间
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			u16Value = (UINT16)(((EV_CHARGE_INFO*)PEInfo)->fBMS_ChargeTime[GUN_NO_B]);
			break;						

		case TOPWAY_16BIT_ADDR_CHG_GUN_B_ENERGY:// = 0x00081104,		//B枪 启动电量
			u16Value = (UINT16)(gEvChargeInfo.fTotalOutEnergy[1]*100); 			
			break;	

		case TOPWAY_16BIT_ADDR_CHG_GUN_B_MONEY:// = 0x00081106,			//B枪 已充金额
			u16Value = (UINT16)(gEvChargeInfo.fCostMoney[1] *100);
			break;

		case TOPWAY_16BIT_ADDR_CHG_GUN_B_REMAIN_TIME:// = 0x00081108,	//B枪 剩余时间
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->u16BCS_LeaveTime);
			break;

		case TOPWAY_16BIT_ADDR_CHG_GUN_B_REQ_VOLT:// = 0x0008110A,		//B枪 需求电压 
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBMSRequireVolt * 10);
			break;		

		case TOPWAY_16BIT_ADDR_CHG_GUN_B_REQ_CURR:// = 0x0008110C,		//B枪 需求电流
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBMSRequireCurr * 10);
			break;					

		case TOPWAY_16BIT_ADDR_CHG_GUN_B_OUT_VOLT: // = 0x0008110E,		//B枪 输出电压
			PEInfo = GetgEquipInfo(E_RECT_INFO);
			u16Value = (UINT16)(((CANCommData_TypeDef*)PEInfo)->GrpData[GRP_B].fOutVolt * 10);
			break;

		case TOPWAY_16BIT_ADDR_CHG_GUN_B_OUT_CURR:// = 0x00081110,		//B枪 输出电流
			//电表正常时使用电表读数
			/*if((gWH_Info[GUN_NO_B].u8WH_ALM_Mask == FALSE) && (gWH_Info[GUN_NO_B].u8WHCommAlm == FALSE))
			{
				u16Value = (UINT16)(gWH_Info[GUN_NO_B].fWH_A_Curr * 10);
			}
			else*/
			if(gs_CANComm.bIsRingEnabled == TRUE)
			{
				u16Value = (UINT16)(g_pRing_B->master.fTotalOutCurr * 10);
			}
			else
			{
				PEInfo = GetgEquipInfo(E_RECT_INFO);
				u16Value = (UINT16)(((CANCommData_TypeDef*)PEInfo)->GrpData[GRP_B].fOutCurr * 10);	

				if (gEvChargeInfo.RectOwner[GUN_NO_B] == GRP_A)
				{
					u16Value = 0;
				}
				if (gEvChargeInfo.RectOwner[GUN_NO_A] == GRP_B)
				{
					u16Value += (UINT16)(((CANCommData_TypeDef*)PEInfo)->GrpData[GRP_A].fOutCurr * 10);
				}				
			}			
			break;									

		case TOPWAY_16BIT_ADDR_CHG_GUN_B_SOC:// = 0x00081112,			//B枪 SOC
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCS_SOC);
			break;	
        case TOPWAY_16BIT_ADDR_CHG_GUN_B_CHG_STATE:   //充电阶段提示
			if(gEvChargeInfo.u8_Charge_CMD[GUN_NO_B] == START_CHARGE_VAL)
			{
				if(gEvChargeInfo.RectOwner[GUN_NO_B] == GRP_A)
				{
					u16Value = 3;   //等待另侧释放
				}
				else if(gBms_2_CommInfo.i8_CMD_Phase == HANDSHAKE_SELF_CHECK)
				{
					u16Value = 0;  //自检
				}
				else if(((gBms_2_CommInfo.i8_CMD_Phase > HANDSHAKE_SELF_CHECK) && (gBms_2_CommInfo.i8_CMD_Phase < CHARGING_RCV_BCL_SEND_CCS))
					|| (gBms_2_CommInfo.i8_CMD_Phase == EV_CEM_XXXX))
				{
					u16Value = 1;  //配置
				}
				else if(gBms_2_CommInfo.i8_CMD_Phase == CHARGING_RCV_BCL_SEND_CCS)
				{
					if((gs_CANComm.bIsRingEnabled == TRUE)
						&& (g_pRing_B->master.nSlaveTotal > 0))
					{
						u16Value = 5;  //充电中且并机
					}
					else if(gEvChargeInfo.RectOwner[GUN_NO_A] == GRP_B)
					{
						u16Value = 5;  //充电中且并机
					}
					else
					{
						u16Value = 2;  //充电中
					}
				}
				else
				{
					u16Value = 4;  //停止
				}				
			}
			else
			{
				u16Value = 4;  //停止
			}

			break;
                    case TOPWAY_16BIT_ADDR_CHG_GUN_B_SOC_ANIMATION:// = 0x00081112,			//B枪 SOC
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCS_SOC);
                        
            if(gBms_2_CommInfo.i8_CMD_Phase == CHARGING_RCV_BCL_SEND_CCS)
            {
				if(gs_DisplayCtrl.u8SocAnimationStep[1] == 0)
				{
					u16Value += SOC_DISP_ANIMATION_STEP;
					gs_DisplayCtrl.u8SocAnimationStep[1] = 1;
					if(u16Value >= 100)
					{
						gs_DisplayCtrl.u8SocAnimationStep[1] = 2;
					}
				}
				else if(gs_DisplayCtrl.u8SocAnimationStep[1] == 1)
				{
					u16Value += (SOC_DISP_ANIMATION_STEP*2);
					gs_DisplayCtrl.u8SocAnimationStep[1] = 2;
				}
				else
				{
					gs_DisplayCtrl.u8SocAnimationStep[1] = 0;
				}
                if(u16Value > 100)
                {
                    u16Value = 100;
                }
            }
                          
			break;		

/********************************************************************************************************************/
/************************************************信号类型分界********************************************************/
/********************************************************************************************************************/
			//B枪详细信息页面 0x00082130~0x00821FF	
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_RECT_NUMBER:// = 0x00081130,	//B枪 整流模块个数
			PEInfo = GetgEquipInfo(E_RECT_INFO);
			u16Value = (UINT16)(((CANCommData_TypeDef*)PEInfo)->GrpData[GRP_B].nCommRectNum);
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_AC_VOLT_A:// = 0x00081132,		//B枪 AB线电压
			PEInfo = GetgEquipInfo(E_RECT_INFO);
			u16Value = (UINT16)(((CANCommData_TypeDef*)PEInfo)->RectData[1].fAB_Volt * 10);
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_AC_VOLT_B:// = 0x00081134,		//B枪 BC线电压
			PEInfo = GetgEquipInfo(E_RECT_INFO);
			u16Value = (UINT16)(((CANCommData_TypeDef*)PEInfo)->RectData[1].fBC_Volt * 10);
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_AC_VOLT_C:// = 0x00081136,		//B枪 CA线电压
			PEInfo = GetgEquipInfo(E_RECT_INFO);
			u16Value = (UINT16)(((CANCommData_TypeDef*)PEInfo)->RectData[1].fCA_Volt * 10);
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_CC1_VOLT:// = 0x00081138,		//B枪 CC1电压
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			u16Value = (UINT16)(((EV_CHARGE_INFO*)PEInfo)->fCC1_2VoltVal *10);
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_SYS_TEM:// = 0x0008113A,		//B枪 系统温度
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			if (((EV_CHARGE_INFO*)PEInfo)->fEV_InterTemp >= 0)
			{
				u16Value = (UINT16)(((EV_CHARGE_INFO*)PEInfo)->fEV_InterTemp *10);
			}
			else
			{
				iTempVal = ABS((int)(((EV_CHARGE_INFO*)PEInfo)->fEV_InterTemp * 10));
				iTempVal = (~(iTempVal-1))&0xffff;
				u16Value = iTempVal;
			}
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_ELOCK_STAT:// = 0x0008113C,	//B枪 电子锁状态
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->u8ElecLock_Alm);
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_METER_CURR:// = 0x0008113E,	//B枪 电表电流
			PEInfo = GetgEquipInfo(E_TYPE_WH2);
			u16Value = (UINT16)(((stWHInfo*)PEInfo)->fWH_A_Curr * 10);
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_BATT_TYPE:// = 0x00081140,		//B枪 电池类型
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->u8BRM_BattType);
			break;		

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_ALLOW_VOLT_MAX:// = 0x00081142,//B枪 最高允许电压
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCP_MaxChargeVolt * 10);
			break;								

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_ALLOW_TEM_MAX:// = 0x00081144,	//B枪 最高允许温度
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			if (((stBMS_INFO*)PEInfo)->fBCP_MaxAllowTemp >= 0)
			{
				u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCP_MaxAllowTemp *10);
			}
			else
			{
				iTempVal = ABS((int)(((stBMS_INFO*)PEInfo)->fBCP_MaxAllowTemp * 10));
				iTempVal = (~(iTempVal-1))&0xffff;
				u16Value = iTempVal;
			}
			break;						

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_ALLOW_CURR_MAX:// = 0x00081146,//B枪 最高允许电流
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCP_MaxAllowCurr * 10);
			break;					

        case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_ALLOW_CELL_V_MAX:// = 0x00081148,//B枪 最高允许单体电压
				PEInfo = GetgEquipInfo(E_TYPE_BMS2);
				u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCP_CellMaxVolt * 10);
				break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_BMS_RP_VOLT:// = 0x0008114A,	//B枪 BMS上报电压
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCS_MeasureVolt * 10);
			break;			

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_BMS_RP_CURR:// = 0x0008114C,	//B枪 BMS上报电流
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCS_MeasureCurr * 10);
			break;					

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_BATT_RATED_CAP:// = 0x0008114E,	//B枪 额定容量
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->u8BRM_RatedCAP * 10);
			break;			

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_BMS_RP_MAX_CELL_V:// = 0x00081150,	//B枪 BMS上报最高单体电压
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			u16Value = (UINT16)(((stBMS_INFO*)PEInfo)->fBCS_MaxCellVolt * 10);
			break;

		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_RES_P2PE:
			u16Value = (UINT16)(gIMIU_Info2.fJYMP2gResist[0] *10);
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_RES_N2PE:
			u16Value = (UINT16)(gIMIU_Info2.fJYMN2gResist[0] *10);
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_IMIU_VOLT:
			u16Value = (UINT16)(gIMIU_Info2.fJYMVolt[0] *10);
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_BATT_VOLT:
			u16Value = (UINT16)(gEvChargeInfo.fEV_BattVolt_2 *10);
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_BATT_MAX_TEMP:
			union_16bit_value.i16Value = (short)gEVBms_2_Info.fBSM_MaxBattTemp;
			u16Value = union_16bit_value.u16Value;
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_BATT_MIN_TEMP:
			union_16bit_value.i16Value = (short)gEVBms_2_Info.fBSM_MinBattTemp;
			u16Value = union_16bit_value.u16Value;
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_MAX_OUT_CURR:
			union_16bit_value.i16Value = (short)gs_CANComm.GrpData[GRP_B].fMax_OutCurr;
			u16Value = union_16bit_value.u16Value;
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_MAX_OUT_VOLT:
			union_16bit_value.i16Value = (short)gs_CANComm.GrpData[GRP_B].fMax_OutVolt;
			u16Value = union_16bit_value.u16Value;
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_RATE_OUT_PWR:
			union_16bit_value.i16Value = (short)gs_CANComm.GrpData[GRP_B].fRatedPower;
			u16Value = union_16bit_value.u16Value;
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_MIN_OUT_VOLT:
			union_16bit_value.i16Value = (short)gs_CANComm.GrpData[GRP_B].fMin_OutVolt;
			u16Value = union_16bit_value.u16Value;
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_CHG_CTRL_CRUU:
			u16Value = (unsigned short)(gEvChargeInfo.fNowRectCtrlOutCurrent[GUN_NO_B]*10);
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_BCP_BATTVOLT:
			u16Value = (unsigned short)(gEVBms_2_Info.fBCP_CurrBattVolt*10);
			break;
		case TOPWAY_16BIT_ADDR_DETAILS_GUN_B_BMS_VER:
			if (gEvChargeInfo.u8Is_PUTIAN_V15[GUN_NO_B] == IS_PUTIAN_BMS)
			{
				u16Value = 2;
			}
			else
			{
				u16Value = (UINT16)gEVBms_2_Info.u8BMSVersion;
			}
			break;

			

/********************************************************************************************************************/
/************************************************信号类型分界********************************************************/
/********************************************************************************************************************/
		//A枪启动控制 0x00081000~0x008103F	
		case TOPWAY_16BIT_ADDR_START_GUN_A_STAT:// = 0x00081000,		//A枪 是否被选中 0-枪有故障不可用 1-枪可用待选中 2-已选中 3-直接可刷卡 4-预约中
			//单枪模式
			if(gEvChargeInfo.u8IsSingleGunMode == TRUE)  
			{
				if ((gEvChargeInfo.u8SysAlm == TRUE) || (gEvChargeInfo.u8Gun_Alm[GUN_NO_A] == TRUE))
				{
					u16Value = 0;
				}		
				else if(gs_EthAppCommMng.u8OrderChargeCMD[0] == TRUE)
				{
					u16Value = 2;
				}				
				else
				{
					u16Value = 1;
				}
			}
			else
			{
				if ((gEvChargeInfo.u8SysAlm == TRUE) || (gEvChargeInfo.u8Gun_Alm[GUN_NO_A] == TRUE))
				{
					u16Value = 0;
				}			
				else if(gs_EthAppCommMng.u8OrderChargeCMD[0] == TRUE)
				{
					u16Value = 4;
				}
				else if((gs_CANComm.bIsRingEnabled == TRUE)
					&& (g_pRing_A->pNodeMe->emLockState == _LOCK_AS_SLAVE))
				{
					u16Value = 5;  //环网 从机
				}
				else if((gs_CANComm.bIsRingEnabled == FALSE)
					&& (gBms_2_CommInfo.i8_CMD_Phase == CHARGING_RCV_BCL_SEND_CCS)
					&& (gEvChargeInfo.RectOwner[GUN_NO_A] == GRP_B))
				{
					u16Value = 5;  //非环网 被并机
				}
				else if((gs_DisplayCtrl.u8CurrPageNo == TOPWAY_SCREEM_PAGE_INIT)
					||(gs_DisplayCtrl.u8CurrPageNo == TOPWAY_SCREEM_PAGE_INIT_Single))
				{		
					if(gs_EthAppCommMng.u8OrderChargeCMD[1] == TRUE)
					{
						u16Value = 3;
					}
					else if(gEvChargeInfo.u8GunSelect == 1)
					{
						u16Value = 2;
					}
					else
					{
						u16Value = 1;
					}
				}			
				else
				{
					u16Value = 3;
				}
			}
			break;

		case TOPWAY_16BIT_ADDR_START_GUN_A_BMS_VOLT: // = 0x00081002,	//A枪 辅助电源模式 0-12V  1-24V
			u16Value = (UINT16)(gEvChargeInfo.u8DisplayBMSPowerType[GUN_NO_A]);
			break;

		case TOPWAY_16BIT_ADDR_START_GUN_A_SEL_STAT:// = 0x00081004,	//A枪 是否被选中
			//预留
			break;

		case TOPWAY_16BIT_ADDR_START_GUN_A_DISP_MONEY_NOT_ENOUGH: //A枪 是否显示 卡内余额不足
			u16Value = gs_DisplayCtrl.u8CardMoneyNotEnoughNoticeDelay[0];
			break;	
		case TOPWAY_16BIT_ADDR_START_GUN_A_RESERVE_STAT:
			//故障中，不能被预约
			if ((TRUE == gEvChargeInfo.u8SysAlm) || (TRUE == gEvChargeInfo.u8Gun_Alm[GUN_NO_A]))  
			{
				u16Value = 0;
			}
			else if(gs_EthAppCommMng.u8OrderChargeCMD[0] == TRUE)//预约中
			{
				u16Value = 1;	
			}
			break;
		case TOPWAY_16BIT_ADDR_START_GUN_A_RESERVE_LEFT_TIME:
			iTempVal = gs_EthAppCommMng.u16OrderTimeOutCount[0];
			u16Value = iTempVal/60;
			if((iTempVal%60) > 0)
			{
				u16Value += 1;
			}			
			break;

		case TOPWAY_16BIT_ADDR_CHG_GUN_A_IS_ADMIN_CHG:
		//case TOPWAY_16BIT_ADDR_START_GUN_A_IS_ADMIN_CHG:
			if((gEvChargeInfo.u8DisplayStopKey == TRUE)
			||(gEvChargeInfo.u8LogInMode[GUN_NO_A] == EV_ENTER_admin)
			||(gEvChargeInfo.u8_StartReason[GUN_NO_A] == EV_ENTER_VIN))
			{
				u16Value = 1;
			}
			break;
		case TOPWAY_16BIT_ADDR_START_GUN_A_RING_IS_AS_SLAVE:  // = 0x0008100C, //A枪 环网中是否锁定为从机
			if((gs_CANComm.bIsRingEnabled == TRUE)
				&& (g_pRing_A->pNodeMe->emLockState == _LOCK_AS_SLAVE))
			{
				u16Value = 1;  //环网 从机
			}
			break;
		case TOPWAY_16BIT_ADDR_START_GUN_A_RING_MASTER_ID: // = 0x0008100E, //A枪 环网中主机是谁
			if((g_pRing_A->pNodeMe->nLockedMasterID > 0)
				&& (g_pRing_A->pNodeMe->nLockedMasterID < 33))
			{				
				u16Value = g_pRing_A->pNodeMe->nLockedMasterID-1;  
			}
			break;

		case TOPWAY_16BIT_ADDR_START_GUN_A_CHG_MODE: //= 0x00081010,	//A枪 启动模式选择 0-自动充满 1-按时间 2-按电量 3-按金额 4-按SOC
			u16Value = (UINT16)gEvChargeInfo.u8ChargeMode[GUN_NO_A];
			break;

		case TOPWAY_16BIT_ADDR_START_GUN_A_SET_CHG_TIME: // = 0x00081012,//A枪 按时间方式充电 设定时间
			u16Value = (UINT16)gTempChargeArgs.fTimeArgs;
			break;
		case TOPWAY_16BIT_ADDR_START_GUN_A_SET_CHG_ENERGY: // = 0x00081014,//A枪 按时间方式充电 设定电量
			u16Value = (UINT16)gTempChargeArgs.fEnergeArgs;
			break;
		//case TOPWAY_16BIT_ADDR_START_GUN_A_SET_CHG_MONEY:// = 0x00081016,//A枪 按时间方式充电 设定金额
		//	u16Value = (UINT16)(gTempChargeArgs.fMoney);
		//	break;

		case TOPWAY_16BIT_ADDR_START_GUN_A_SET_CHG_SOC:// = 0x00081018,	//A枪 按时间方式充电 设定SOC
			u16Value = (UINT16)(gTempChargeArgs.fSOCArgs);
			break;

		case TOPWAY_16BIT_ADDR_CHG_GUN_A_START_WAY:
		case TOPWAY_16BIT_ADDR_START_GUN_A_START_WAY:// = 0x0008101A,	//A枪 启动方式 0-刷卡 1-网络
			//u16Value = gEvChargeInfo.u8_StartReason[GUN_NO_A];
			if(gEvChargeInfo.u8DisplayStopKey == TRUE)
			{
				u16Value = 2;
			}
			else if((gEvChargeInfo.u8LogInMode[GUN_NO_A] == EV_ENTER_IC_CARD)||(gEvChargeInfo.u8LogInMode[GUN_NO_A] == EV_ENTER_IC_CARD_NET))
			{
				u16Value = 0;
			}
			else if(gEvChargeInfo.u8LogInMode[GUN_NO_A] == EV_ENTER_admin)
			{
				u16Value = 2;
			}
			else if(gEvChargeInfo.u8LogInMode[GUN_NO_A] == EV_ENTER_APP)  //空白
			{
				u16Value = 1;
			}
			else if(gEvChargeInfo.u8LogInMode[GUN_NO_A] == EV_ENTER_VIN)  //空白
			{
				u16Value = 2;
			}
			break;
		case TOPWAY_16BIT_ADDR_START_GUN_A_VIN_ENABLE:
			u16Value = gEvChargeInfo.u8VinChgEn;
			break;
		case TOPWAY_16BIT_ADDR_START_GUN_A_BMS_SET_ENABLE:
			u16Value = gEvChargeInfo.u8UserSetBMSPower;
			break;

		//A枪结算控制 0x00081040~0x008107F	
		case TOPWAY_16BIT_ADDR_STOP_GUN_A_MONEY:// = 0x00081040,		//A枪 结算金额
			//u16Value = (UINT16)(gA_Result.fMoney * 100);
			u16Value = (UINT16)(gEvChargeInfo.fCostMoney[0] *100);
			break;

		case TOPWAY_16BIT_ADDR_STOP_GUN_A_ENERGY:// = 0x00081042,		//A枪 结算 总充电量
			//if(gEvChargeInfo.u8SetCalcMoneyType == 1)
			//{
				u16Value = (UINT16)(gEvChargeInfo.fTotalOutEnergy[0]*100); 
			//}
			/*else 
			{
				u16Value = (UINT16)(gA_Result.fEnergy*100);
			}*/
			break;

		case TOPWAY_16BIT_ADDR_STOP_GUN_A_SOC:// = 0x00081044,			//A枪 结算 结束SOC
			u16Value = gA_Result.u8E_SOC;
			break;

		case TOPWAY_16BIT_ADDR_STOP_GUN_A_TIME:// = 0x00081046,			//A枪 结算 充电时间
			/*u16Value = (unsigned short)gA_Result.u8Keephour*60 + gA_Result.u8KeepEmin;
			if(gA_Result.u8KeepESec > 0)
			{
				u16Value += 1;
			}*/
			u16Value = (unsigned short)(gA_Result.fChargeTime);
			break;

		case TOPWAY_16BIT_ADDR_STOP_GUN_A_END_REASON:// = 0x00081048,	//A枪 结算 结束原因
			u16Value = gA_Result.u8LastReason;
			break;

		case TOPWAY_16BIT_ADDR_STOP_GUN_A_NOTICE_BRUSH:// = 0x0008104A,	//A枪 结算 提示刷卡
			u16Value = gs_DisplayCtrl.u8NeedBrushJiesuan[0];
			break;

		case TOPWAY_16BIT_ADDR_STOP_GUN_A_EN_CONFER_KEY:// = 0x0008104C,	//A枪 结算  是否使能返回按键
			if(gs_DisplayCtrl.u8NeedBrushJiesuan[0] == 0)
			{
				u16Value = 1;
			} 
			break;
		
/********************************************************************************************************************/
/************************************************信号类型分界********************************************************/
/********************************************************************************************************************/
		//B枪启动控制 0x00081000~0x008103F	
		case TOPWAY_16BIT_ADDR_START_GUN_B_STAT:// = 0x00081000,		//B枪 是否被选中 0-枪有故障不可用 1-枪可用待选中 2-已选中 3-直接可刷卡
			if ((gEvChargeInfo.u8SysAlm == TRUE) || (gEvChargeInfo.u8Gun_Alm[GUN_NO_B] == TRUE))
			{
				u16Value = 0;
			}			
			else if(gs_EthAppCommMng.u8OrderChargeCMD[1] == TRUE)
			{
				u16Value = 4;
			}
			else if((gs_CANComm.bIsRingEnabled == TRUE)
				&& (g_pRing_B->pNodeMe->emLockState == _LOCK_AS_SLAVE))
			{
				u16Value = 5;  //环网 从机
			}
			else if((gs_CANComm.bIsRingEnabled == FALSE)
				&& (gBms_1_CommInfo.i8_CMD_Phase == CHARGING_RCV_BCL_SEND_CCS)
				&& (gEvChargeInfo.RectOwner[GUN_NO_B] == GRP_A))
			{
				u16Value = 5;  //非环网 被并机
			}
			else if(gs_DisplayCtrl.u8CurrPageNo == TOPWAY_SCREEM_PAGE_INIT)
			{
				if(gs_EthAppCommMng.u8OrderChargeCMD[0] == TRUE)
				{
					u16Value = 3;
				}
				else if(gEvChargeInfo.u8GunSelect == 2)
				{
					u16Value = 2;
				}
				else
				{
					u16Value = 1;
				}
			}			
			else
			{
				u16Value = 3;
			}
			break;

		case TOPWAY_16BIT_ADDR_START_GUN_B_BMS_VOLT: // = 0x00081002,	//B枪 辅助电源模式 0-12V  1-24V
			u16Value = (UINT16)(gEvChargeInfo.u8DisplayBMSPowerType[GUN_NO_B]);
			break;

		case TOPWAY_16BIT_ADDR_START_GUN_B_SEL_STAT:// = 0x00081004,	//B枪 是否被选中
			//预留
			break;
		case TOPWAY_16BIT_ADDR_START_GUN_B_DISP_MONEY_NOT_ENOUGH: //B枪 是否显示 卡内余额不足
			u16Value = gs_DisplayCtrl.u8CardMoneyNotEnoughNoticeDelay[1];
			break;	
		case TOPWAY_16BIT_ADDR_START_GUN_B_RESERVE_STAT:
			//故障中，不能被预约
			if ((TRUE == gEvChargeInfo.u8SysAlm) || (TRUE == gEvChargeInfo.u8Gun_Alm[GUN_NO_B]))  
			{
				u16Value = 0;
			}
			else if(gs_EthAppCommMng.u8OrderChargeCMD[1] == TRUE)//预约中
			{
				u16Value = 1;	
			}
			break;
		case TOPWAY_16BIT_ADDR_START_GUN_B_RESERVE_LEFT_TIME:
			iTempVal = gs_EthAppCommMng.u16OrderTimeOutCount[1];
			u16Value = iTempVal/60;
			if((iTempVal%60) > 0)
			{
				u16Value += 1;
			}			
			break;

		case TOPWAY_16BIT_ADDR_CHG_GUN_B_IS_ADMIN_CHG:
			if((gEvChargeInfo.u8DisplayStopKey == TRUE)
				||(gEvChargeInfo.u8LogInMode[GUN_NO_B] == EV_ENTER_admin)
				||(gEvChargeInfo.u8_StartReason[GUN_NO_B] == EV_ENTER_VIN))
			{
				u16Value = 1;
			}
			break;

		case TOPWAY_16BIT_ADDR_START_GUN_B_RING_IS_AS_SLAVE:  // = 0x0008200C, //B枪 环网中是否锁定为从机
			if((gs_CANComm.bIsRingEnabled == TRUE)
				&& (g_pRing_B->pNodeMe->emLockState == _LOCK_AS_SLAVE))
			{
				u16Value = 1;  //环网 从机
			}
			break;
		case TOPWAY_16BIT_ADDR_START_GUN_B_RING_MASTER_ID: // = 0x0008200E, //B枪 环网中主机是谁
			if((g_pRing_B->pNodeMe->nLockedMasterID > 0)
				&& (g_pRing_B->pNodeMe->nLockedMasterID < 33))
			{				
				u16Value = g_pRing_B->pNodeMe->nLockedMasterID-1;  
			}
			break;

		case TOPWAY_16BIT_ADDR_START_GUN_B_CHG_MODE: //= 0x00081010,	//B枪 启动模式选择 0-自动充满 1-按时间 2-按电量 3-按金额 4-按SOC
			u16Value = (UINT16)gEvChargeInfo.u8ChargeMode[GUN_NO_B];
			break;

		case TOPWAY_16BIT_ADDR_START_GUN_B_SET_CHG_TIME: // = 0x00081012,//B枪 按时间方式充电 设定时间
			u16Value = (UINT16)gTempChargeArgs.fTimeArgs;
			break;
		case TOPWAY_16BIT_ADDR_START_GUN_B_SET_CHG_ENERGY: // = 0x00081014,//B枪 按时间方式充电 设定电量
			u16Value = (UINT16)gTempChargeArgs.fEnergeArgs;
			break;
		//case TOPWAY_16BIT_ADDR_START_GUN_B_SET_CHG_MONEY:// = 0x00081016,//B枪 按时间方式充电 设定金额
		//	u16Value = (UINT16)(gTempChargeArgs.fMoney);
		//	break;

		case TOPWAY_16BIT_ADDR_START_GUN_B_SET_CHG_SOC:// = 0x00081018,	//B枪 按时间方式充电 设定SOC
			u16Value = (UINT16)(gTempChargeArgs.fSOCArgs);
			break;

		case TOPWAY_16BIT_ADDR_CHG_GUN_B_START_WAY:
		case TOPWAY_16BIT_ADDR_START_GUN_B_START_WAY:// = 0x0008101A,	//B枪 启动方式 0-刷卡 1-网络
			if(gEvChargeInfo.u8DisplayStopKey == TRUE)
			{
				u16Value = 2;
			}
			else if((gEvChargeInfo.u8LogInMode[GUN_NO_B] == EV_ENTER_IC_CARD)||(gEvChargeInfo.u8LogInMode[GUN_NO_B] == EV_ENTER_IC_CARD_NET))
			{
				u16Value = 0;
			}
			else if(gEvChargeInfo.u8LogInMode[GUN_NO_B] == EV_ENTER_admin)
			{
				u16Value = 2;
			}
			else if(gEvChargeInfo.u8LogInMode[GUN_NO_B] == EV_ENTER_APP)  //空白
			{
				u16Value = 1;
			}
			else if(gEvChargeInfo.u8LogInMode[GUN_NO_B] == EV_ENTER_VIN)  //空白
			{
				u16Value = 2;
			}
			break;
		case TOPWAY_16BIT_ADDR_START_GUN_B_VIN_ENABLE:
			u16Value = gEvChargeInfo.u8VinChgEn;
			break;
		case TOPWAY_16BIT_ADDR_START_GUN_B_BMS_SET_ENABLE:
			u16Value = gEvChargeInfo.u8UserSetBMSPower;
			break;
		//B枪结算控制 0x00081040~0x008107F	
		case TOPWAY_16BIT_ADDR_STOP_GUN_B_MONEY:// = 0x00081040,		//B枪 结算金额
			//u16Value = (UINT16)(gB_Result.fMoney * 100);
			u16Value = (UINT16)(gEvChargeInfo.fCostMoney[1] *100);
			break;

		case TOPWAY_16BIT_ADDR_STOP_GUN_B_ENERGY:// = 0x00081042,		//B枪 结算 总充电量
			//if(gEvChargeInfo.u8SetCalcMoneyType == 1)
			//{
				u16Value = (UINT16)(gEvChargeInfo.fTotalOutEnergy[1]*100); 
			//}
			/*else 
			{
				u16Value = (UINT16)(gB_Result.fEnergy*100);
			}*/
			break;

		case TOPWAY_16BIT_ADDR_STOP_GUN_B_SOC:// = 0x00081044,			//B枪 结算 结束SOC
			u16Value = gB_Result.u8E_SOC;
			break;                

		case TOPWAY_16BIT_ADDR_STOP_GUN_B_TIME:// = 0x00081046,			//B枪 结算 充电时间
			u16Value = (unsigned short)(gB_Result.fChargeTime);
			break;

		case TOPWAY_16BIT_ADDR_STOP_GUN_B_END_REASON:// = 0x00081048,	//B枪 结算 结束原因
			u16Value = gB_Result.u8LastReason;
			break;

		case TOPWAY_16BIT_ADDR_STOP_GUN_B_NOTICE_BRUSH:// = 0x0008104A,	//B枪 结算 提示刷卡
			u16Value = gs_DisplayCtrl.u8NeedBrushJiesuan[1];
			break;

		case TOPWAY_16BIT_ADDR_STOP_GUN_B_EN_CONFER_KEY:// = 0x0008104C,	//B枪 结算  是否使能返回按键
			if(gs_DisplayCtrl.u8NeedBrushJiesuan[1] == 0)
			{
				u16Value = 1;
			} 
			break;
		
	
/********************************************************************************************************************/
/************************************************信号类型分界********************************************************/
/********************************************************************************************************************/
//充电记录 数据 0x00080C00~0x0080CFF
		case TOPWAY_16BIT_ADDR_RECORD_TOTAL_NUMBER:// = 0x00080C00,		//充电记录 总数量
			if(gChargeLogTable.u32TotalNum > MAX_RECORD_NUMBER)
			{
				u16Value = MAX_RECORD_NUMBER;
			}
			else
			{
				u16Value = (UINT16)gChargeLogTable.u32TotalNum;
			}
			break;
		case TOPWAY_16BIT_ADDR_RECORD_NO:// = 0x00080C02,				//充电记录 当前序号
			if(gChargeLogTable.u32TotalNum > 0)
			{				
				if(gChargeLogTable.u32TotalNum > MAX_RECORD_NUMBER)
				{
					u16temp = (UINT16)(gChargeLogTable.u32TotalNum - gFlashOptInfo.u32ViewRecordNo);

					u16Value = MAX_RECORD_NUMBER - u16temp;
				}
				else
				{
					u16Value = (UINT16)gFlashOptInfo.u32ViewRecordNo;
				}				
			}
			else
			{
				u16Value = 0;
			}

			break;
		case TOPWAY_16BIT_ADDR_RECORD_CHG_DURATION:// = 0x00080C04,		//充电记录 充电持续时间 时
			u16Value = (UINT16)ViewHour;
			break;
		case TOPWAY_16BIT_ADDR_RECORD_CHG_ENERGY:// = 0x00080C06,		//充电记录 累计电量
			if(gEvChargeInfo.u8SetCalcMoneyType == 1)
			{
				u16Value = (UINT16)(stViewChargeRecordFlash.fTotalEnergyKWH * 100);
			}
			else
			{
				u16Value = (UINT16)((stViewChargeRecordFlash.fStopWHValue - stViewChargeRecordFlash.fStartWHValue) * 100);
			}
			break;
		case TOPWAY_16BIT_ADDR_RECORD_START_WAY:// = 0x00080C08,		//充电记录 启动方式
			if((stViewChargeRecordFlash.u8LogInType == EV_ENTER_IC_CARD)||(stViewChargeRecordFlash.u8LogInType == EV_ENTER_IC_CARD_NET))
			{
				u16Value = 0;
			}
			else if(stViewChargeRecordFlash.u8LogInType == EV_ENTER_admin)
			{
				u16Value = 2;
			}
			else if(stViewChargeRecordFlash.u8LogInType == EV_ENTER_APP)  //空白
			{
				u16Value = 1;
			}
			else if(stViewChargeRecordFlash.u8LogInType == EV_ENTER_VIN)  //
			{
				u16Value = 3;
			}
			break;
		case TOPWAY_16BIT_ADDR_RECORD_END_REASON:// = 0x00080C0A,		//充电记录 结束原因
			u16Value = (UINT16)stViewChargeRecordFlash.u8StopReason;
			break;

		case TOPWAY_16BIT_ADDR_RECORD_START_TIME_YEAR:// = 0x00080C0C,	//充电记录 开始时间 年
			u16Value = (UINT16)stViewChargeRecordFlash.StartTime.tm_year[1]*256 + (UINT16)stViewChargeRecordFlash.StartTime.tm_year[0];
			break;

		case TOPWAY_16BIT_ADDR_RECORD_START_TIME_MONTH:// = 0x00080C0E,	//充电记录 开始时间 月
			u16Value = (UINT16)stViewChargeRecordFlash.StartTime.tm_mon;
			break;

		case TOPWAY_16BIT_ADDR_RECORD_START_TIME_DAY: // = 0x00080C10,	//充电记录 开始时间 日
			u16Value = (UINT16)stViewChargeRecordFlash.StartTime.tm_mday;
			break;

		case TOPWAY_16BIT_ADDR_RECORD_START_TIME_HOUR:// = 0x00080C12,	//充电记录 开始时间 时
			u16Value = (UINT16)stViewChargeRecordFlash.StartTime.tm_hour;
			break;

		case TOPWAY_16BIT_ADDR_RECORD_START_TIME_MIN:// = 0x00080C14,	//充电记录 开始时间 分
			u16Value = (UINT16)stViewChargeRecordFlash.StartTime.tm_min;
			break;

		case TOPWAY_16BIT_ADDR_RECORD_START_TIME_SEC: // = 0x00080C16,	//充电记录 开始时间 秒
			u16Value = (UINT16)stViewChargeRecordFlash.StartTime.tm_sec;
			break;
		case TOPWAY_16BIT_ADDR_RECORD_END_TIME_YEAR:// = 0x00080C18,	//充电记录 结束时间 年
			u16Value = (UINT16)stViewChargeRecordFlash.StopTime.tm_year[1]*256 + (UINT16)stViewChargeRecordFlash.StopTime.tm_year[0];
			break;
		case TOPWAY_16BIT_ADDR_RECORD_END_TIME_MONTH:// = 0x00080C1A,	//充电记录 结束时间 月
			u16Value = (UINT16)stViewChargeRecordFlash.StopTime.tm_mon;
			break;

		case TOPWAY_16BIT_ADDR_RECORD_END_TIME_DAY:// = 0x00080C1C,		//充电记录 结束时间 日
			u16Value = (UINT16)stViewChargeRecordFlash.StopTime.tm_mday;
			break;
		case TOPWAY_16BIT_ADDR_RECORD_END_TIME_HOUR:// = 0x00080C1E,	//充电记录 结束时间 时
			u16Value = (UINT16)stViewChargeRecordFlash.StopTime.tm_hour;
			break;
		case TOPWAY_16BIT_ADDR_RECORD_END_TIME_MIN:// = 0x00080C20,		//充电记录 结束时间 分
			u16Value = (UINT16)stViewChargeRecordFlash.StopTime.tm_min;
			break;
		case TOPWAY_16BIT_ADDR_RECORD_END_TIME_SEC:// = 0x00080C22,		//充电记录 结束时间 秒
			u16Value = (UINT16)stViewChargeRecordFlash.StopTime.tm_sec;
			break;
		//case TOPWAY_16BIT_ADDR_RECORD_START_METER:// = 0x00080C24,		//充电记录 开始电量
		//	u16Value = (UINT16)(stViewChargeRecordFlash.fStartWHValue* 10);
		//	break;
		//case TOPWAY_16BIT_ADDR_RECORD_END_METER:// = 0x00080C26,		//充电记录 结束电量
		//	u16Value = (UINT16)(stViewChargeRecordFlash.fStopWHValue* 10);
		//	break;		
		case TOPWAY_16BIT_ADDR_RECORD_CHG_DURATION_2:// = 0x00080C28,	//充电记录 充电持续时间 分
			u16Value = (UINT16)ViewMin;
			break;
		case TOPWAY_16BIT_ADDR_RECORD_CHG_DURATION_3: // = 0x00080C2A,	//充电记录 充电持续时间 秒
			u16Value = (UINT16)ViewSec;
			break;
		case TOPWAY_16BIT_ADDR_RECORD_SPEAR_NO:  //充电记录 充电抢号
			if((stViewChargeRecordFlash.u8SpearType > 0) && (stViewChargeRecordFlash.u8SpearType < 3))
			{
				u16Value = stViewChargeRecordFlash.u8SpearType - 1;
			}
			break;
		case TOPWAY_16BIT_ADDR_RECORD_START_SOC:
			u16Value = (UINT16)stViewChargeRecordFlash.u8StartSOC;
			break;
		case TOPWAY_16BIT_ADDR_RECORD_END_SOC:
			u16Value = (UINT16)stViewChargeRecordFlash.u8StopSOC;
			break;
		case TOPWAY_16BIT_ADDR_RECORD_OVER_VOLT_DISP_EN:
			if((stViewChargeRecordFlash.u8StopReason == CHARGE_BUS_OVER_VOLT)
				|| (stViewChargeRecordFlash.u8StopReason == CHARGE_OVER_CURR_ALM)
				|| (stViewChargeRecordFlash.u8StopReason == CEM_RCV_BCS_OR_S_CRO_TIMEOUT)
				|| (stViewChargeRecordFlash.u8StopReason == CRO_BUS_VOLT_ERR)
				)
			{
				u16Value = 1;
			}
			break;
		case TOPWAY_16BIT_ADDR_RECORD_OVER_VOLT_1:
			u16Value = (UINT16)(stViewChargeRecordFlash.fOverVoltValue[0] * 10);
			break;
		case TOPWAY_16BIT_ADDR_RECORD_OVER_VOLT_2:
			u16Value = (UINT16)(stViewChargeRecordFlash.fOverVoltValue[1] * 10);
			break;
		case TOPWAY_16BIT_ADDR_RECORD_OVER_VOLT_3:
			u16Value = (UINT16)(stViewChargeRecordFlash.fOverVoltValue[2] * 10);
			break;

	
/********************************************************************************************************************/
/************************************************信号类型分界********************************************************/
/********************************************************************************************************************/
	//调测控制 数据 0x00080BC0~0x0080BEF			
		case TOPWAY_16BIT_ADDR_DEBUG_ONOFF: // = 0x00080BC0,			//调测控制 开关状态
		case TOPWAY_16BIT_ADDR_DEBUG_MCCB_A:// = 0x00080BC2,		//调测控制 A枪接触器
		case TOPWAY_16BIT_ADDR_DEBUG_BMS_12V_A:// = 0x00080BC4,		//调测控制 A枪辅助电源
		case TOPWAY_16BIT_ADDR_DEBUG_LOCK_A:// = 0x00080BC6,		//调测控制 A枪锁
		case TOPWAY_16BIT_ADDR_DEBUG_ALARM_LIGHT_A:// = 0x00080BC8,	//调测控制 A枪告警灯
		case TOPWAY_16BIT_ADDR_DEBUG_CHG_LIGHT_A:// = 0x00080BCA,	//调测控制 A枪充电灯
		case TOPWAY_16BIT_ADDR_DEBUG_RING_RELAY_A:// = 0x00080BCC,	//调测控制 并机接触器
		case TOPWAY_16BIT_ADDR_DEBUG_MCCB_B:// = 0x00080BCE,		//调测控制 B枪接触器
		case TOPWAY_16BIT_ADDR_DEBUG_BMS_12V_B:// = 0x00080BD0,		//调测控制 B枪辅助电源
		case TOPWAY_16BIT_ADDR_DEBUG_LOCK_B:// = 0x00080B2,			//调测控制 B枪锁
		case TOPWAY_16BIT_ADDR_DEBUG_ALARM_LIGHT_B:// = 0x00080BD4,	//调测控制 B枪告警灯
		case TOPWAY_16BIT_ADDR_DEBUG_CHG_LIGHT_B:// = 0x00080BD6,	//调测控制 B枪充电灯
		case TOPWAY_16BIT_ADDR_DEBUG_RING_RELAY_B:// = 0x00080BD8,	//调测控制 环网接触器
		case TOPWAY_16BIT_ADDR_DEBUG_AC_FAN:// = 0x00080BDA,		//调测控制 交流风扇
		case TOPWAY_16BIT_ADDR_DEBUG_DC_FAN:// = 0x00080BDC,		//调测控制 直流风扇
			u8Index = ((TopwayRegAddr -  TOPWAY_16BIT_ADDR_DEBUG_ONOFF)/2);
			u16Value = gEvChargeInfo.u8DebugSig[u8Index];
			break;
		case TOPWAY_16BIT_ADDR_DEBUG_QUIT_DEBUG_EN: // = 0x00080BDE,	//调测控制 退出使能
			if(gEvChargeInfo.u8DebugSig[DEBUG_ONOFF] == 0)
			{
				u16Value = 1;
			}
			break;
/********************************************************************************************************************/
/************************************************信号类型分界********************************************************/
/********************************************************************************************************************/
		case TOPWAY_16BIT_ADDR_PARA_ADJUST_Result1:
			u16Value = gEvChargeInfo.u8_AdjustResult[GUN_NO_A];
			break;
		case TOPWAY_16BIT_ADDR_PARA_ADJUST_Result2:
			u16Value = gEvChargeInfo.u8_AdjustResult[GUN_NO_B];
			break;
		default:
			break;
		
	}
	return u16Value;

}


unsigned long u32TopwayGet32bitsSignal(unsigned long TopwayRegAddr)
{
	__XXX_UNION_VALUE unTempVal;
	//INT32 iTempVal = 0;
	void *PEInfo;
	//static struct tm  tmNow;
	//void *PEInfo_2;
	unsigned short ii;
	//UNUSED(RegAddr);
	UINT32 u32Value = 0;
	unsigned char u8SigType;
	UNUSED(u32Value);

	//浮点参数
	if(((TopwayRegAddr >= TOPWAY_32BIT_FEE_PARA_ADDR_RANGE_START) && (TopwayRegAddr <= TOPWAY_32BIT_FEE_PARA_ADDR_RANGE_END))
		|| ((TopwayRegAddr >= TOPWAY_32BIT_FEE2_PARA_ADDR_RANGE_START) && (TopwayRegAddr <= TOPWAY_32BIT_FEE2_PARA_ADDR_RANGE_END))
		|| ((TopwayRegAddr >= TOPWAY_32BIT_PARA_SYS_ADDR_RANGE_START) && (TopwayRegAddr <= TOPWAY_32BIT_PARA_SYS_ADDR_RANGE_END))
		|| ((TopwayRegAddr >= TOPWAY_32BIT_PARA_A_ADDR_RANGE_START) && (TopwayRegAddr <= TOPWAY_32BIT_PARA_A_ADDR_RANGE_END))
		|| ((TopwayRegAddr >= TOPWAY_32BIT_PARA_B_ADDR_RANGE_START) && (TopwayRegAddr <= TOPWAY_32BIT_PARA_B_ADDR_RANGE_END)))
	{
		for(ii = 0; ii < s_u16DispSigMapNum; ii++)
		{
			if(s_DispSigMap[ii].u32DispSigAddr == TopwayRegAddr)
			{
				ExGetSigInfo(s_DispSigMap[ii].u8Etype, s_DispSigMap[ii].u16Idx, &unTempVal, &u8SigType, BY_SRAM);

				if(u8SigType == IS_CHAR)
				{
					u32Value = unTempVal.chtemp[0];				
				}
				else if(u8SigType == IS_FLOAT)
				{
					u32Value = unTempVal.u32Value;
				}
				else if(u8SigType == IS_ULONG)
				{
					u32Value = unTempVal.u32Value;
				}

				return u32Value;

			}
		}
	}

	switch (TopwayRegAddr)
	{
		case TOPWAY_32BIT_ADDR_CARD_LEAVE_MONEY_FROM_HOST:
			unTempVal.ftemp = gBrushInfo.fCardMoneyFormNet;

			if(unTempVal.ftemp > 99999.99)
			{
				unTempVal.ftemp = 99999.99;
			}
			u32Value = unTempVal.u32Value;
			break;

		case TOPWAY_32BIT_ADDR_GUN_A_METER_VALUE:	// //A枪 电表读数
			PEInfo = GetgEquipInfo(E_TYPE_WH1);
			u32Value = (UINT32)(((UINT32)(((stWHInfo*)PEInfo)->fWHRealValue *1000))&0xffffffff);
			break;

		case TOPWAY_32BIT_ADDR_GUN_B_METER_VALUE:	// //B枪 电表读数
			PEInfo = GetgEquipInfo(E_TYPE_WH2);
			u32Value = (UINT32)(((UINT32)(((stWHInfo*)PEInfo)->fWHRealValue *1000))&0xffffffff);
			break;

		case TOPWAY_32BIT_ADDR_SET_CHG_MONEY:	// 模式选择 充电金额
			unTempVal.ftemp = gTempChargeArgs.fMoney;
			u32Value = unTempVal.u32Value;
			break;
		case TOPWAY_32BIT_ADDR_CARD_LEAVE_MONEY:  //模式选择界面 若是刷卡启动 则显示卡内余额
			if(gEvChargeInfo.u8GunSelect == 1)
			{
				unTempVal.ftemp = gEvChargeInfo.fCardLeaveMoney[0];
			}
			else if(gEvChargeInfo.u8GunSelect == 2)
			{
				unTempVal.ftemp = gEvChargeInfo.fCardLeaveMoney[1];
			}
			else
			{
				unTempVal.ftemp = gBrushInfo.fCARDLeaveMoney;
			}
			if(unTempVal.ftemp > 99999.99)
			{
				unTempVal.ftemp = 99999.99;
			}
			u32Value = unTempVal.u32Value;
			break;
				
		case TOPWAY_32BIT_ADDR_RECORD_START_METER_VALUE://		//充电记录 开始电量
			u32Value = (UINT32)(stViewChargeRecordFlash.fStartWHValue* 1000);
			break;
		case TOPWAY_32BIT_ADDR_RECORD_END_METER_VALUE:// 		//充电记录 结束电量
			u32Value = (UINT32)(stViewChargeRecordFlash.fStopWHValue* 1000);
			break;
		case TOPWAY_32BIT_ADDR_RECORD_NO:// = ,				//充电记录 当前序号
			u32Value = (UINT32)gFlashOptInfo.u32ViewRecordNo;
			break;
		case TOPWAY_32BIT_ADDR_RECORD_TOTAL_NUMBER:// = ,		//充电记录 总数量
			u32Value = (UINT32)gChargeLogTable.u32TotalNum;
			break;
		case TOPWAY_32BIT_ADDR_RECORD_ENERGY_VALUE://		//充电记录 开始电量
			u32Value = (UINT32)(stViewChargeRecordFlash.fTotalEnergyKWH* 1000);
			break;


		//校准数据   A
		case TOPWAY_32BIT_ADDR_GUN_A_ADJUST_REQ_VOLT:
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			unTempVal.ftemp = ((stBMS_INFO*)PEInfo)->fBMSRequireVolt;
			u32Value = unTempVal.u32Value;
			break;		

		case TOPWAY_32BIT_ADDR_GUN_A_ADJUST_REQ_CURR:
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			unTempVal.ftemp = ((stBMS_INFO*)PEInfo)->fBMSRequireCurr;
			u32Value = unTempVal.u32Value;
			break;	

		case TOPWAY_32BIT_ADDR_GUN_A_ADJUST_SAMPL_VOLT:							//BMS测量电压	105	U16			0.1V	0x03
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			unTempVal.ftemp = ((EV_CHARGE_INFO*)PEInfo)->fEV_BattVolt_1;			
			u32Value = unTempVal.u32Value;
			break;		

		case TOPWAY_32BIT_ADDR_GUN_A_ADJUST_IN_A_REALVOLT:					
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			unTempVal.ftemp = ((EV_CHARGE_INFO*)PEInfo)->fBattSet_A_Volt;
			u32Value = unTempVal.u32Value;
			break;

		case TOPWAY_32BIT_ADDR_GUN_A_ADJUST_IN_B_REALVOLT:					
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			unTempVal.ftemp = ((EV_CHARGE_INFO*)PEInfo)->fBattSet_B_Volt;
			u32Value = unTempVal.u32Value;
			break;

		case TOPWAY_32BIT_ADDR_GUN_A_ADJUST_COEFF_K:
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			unTempVal.ftemp = ((EV_CHARGE_INFO*)PEInfo)->fBattVolt_1CoefA;
			u32Value = unTempVal.u32Value;
			break;
		case TOPWAY_32BIT_ADDR_GUN_A_ADJUST_COEFF_B:
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			unTempVal.ftemp = ((EV_CHARGE_INFO*)PEInfo)->fBattVolt_1CoefB;
			u32Value = unTempVal.u32Value;
			break;
		case TOPWAY_32BIT_ADDR_GUN_A_ADJUST_INSUL_COEFF_K:
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			unTempVal.ftemp = ((EV_CHARGE_INFO*)PEInfo)->fHallVoltK;
			u32Value = unTempVal.u32Value;
			break;
		case TOPWAY_32BIT_ADDR_GUN_A_ADJUST_INSUL_STAT:
			if(gEvChargeInfo.u8AdjustHall2Flag == TRUE)
			{
				u32Value = 2;
			}
			else
			{
				u32Value = 0;
			}
			break;
		case TOPWAY_32BIT_ADDR_GUN_A_ADJUST_INSUL_RESULT:
			u32Value = gEvChargeInfo.u8AdjustHall2Result;
			break;

		case TOPWAY_32BIT_ADDR_GUN_A_ADJUST_CTL_CMD:
			//ExGetSigInfo(E_TYPE_SYS, ID_SETDATA_AdjustMode_NUM, &unTempVal, NULL, BY_E2PROM);
			//uctemp = unTempVal.chtemp[0];

			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			u32Value = (UINT32)((EV_CHARGE_INFO*)PEInfo)->u8TestMode[GUN_NO_A];
			//自动校准中
			if((gEvChargeInfo.u8_AutoTestStep > 0) && (u32Value == TRUE))
			{
				u32Value = 2;
			}			
			break;

		//校准数据  B
		case TOPWAY_32BIT_ADDR_GUN_B_ADJUST_REQ_VOLT:
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			unTempVal.ftemp = ((stBMS_INFO*)PEInfo)->fBMSRequireVolt;
			u32Value = unTempVal.u32Value;
			break;		

		case TOPWAY_32BIT_ADDR_GUN_B_ADJUST_REQ_CURR:
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			unTempVal.ftemp = ((stBMS_INFO*)PEInfo)->fBMSRequireCurr;
			u32Value = unTempVal.u32Value;
			break;	

		case TOPWAY_32BIT_ADDR_GUN_B_ADJUST_SAMPL_VOLT:							//BMS测量电压	105	U16			0.1V	0x03
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			unTempVal.ftemp = ((EV_CHARGE_INFO*)PEInfo)->fEV_BattVolt_2;			
			u32Value = unTempVal.u32Value;
			break;				

		case TOPWAY_32BIT_ADDR_GUN_B_ADJUST_IN_A_REALVOLT:					
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			unTempVal.ftemp = ((EV_CHARGE_INFO*)PEInfo)->fBattSet_A_Volt;
			u32Value = unTempVal.u32Value;
			break;

		case TOPWAY_32BIT_ADDR_GUN_B_ADJUST_IN_B_REALVOLT:					
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			unTempVal.ftemp = ((EV_CHARGE_INFO*)PEInfo)->fBattSet_B_Volt;
			u32Value = unTempVal.u32Value;
			break;

		case TOPWAY_32BIT_ADDR_GUN_B_ADJUST_COEFF_K:
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			unTempVal.ftemp = ((EV_CHARGE_INFO*)PEInfo)->fBattVolt_2CoefA;
			u32Value = unTempVal.u32Value;
			break;
		case TOPWAY_32BIT_ADDR_GUN_B_ADJUST_COEFF_B:
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			unTempVal.ftemp = ((EV_CHARGE_INFO*)PEInfo)->fBattVolt_2CoefB;
			u32Value = unTempVal.u32Value;
			break;
		case TOPWAY_32BIT_ADDR_GUN_B_ADJUST_CTL_CMD:
			//ExGetSigInfo(E_TYPE_SYS, ID_SETDATA_AdjustMode_NUM, &unTempVal, NULL, BY_E2PROM);
			//uctemp = unTempVal.chtemp[0];

			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			u32Value = (UINT32)((EV_CHARGE_INFO*)PEInfo)->u8TestMode[GUN_NO_B];
			//自动校准中
			if((gEvChargeInfo.u8_AutoTestStep > 0) && (u32Value == TRUE))
			{
				u32Value = 2;
			}			
			break;
		case TOPWAY_32BIT_ADDR_GUN_A_CHG_ENERGY_VALUE:
			u32Value = (UINT32)(gEvChargeInfo.fTotalOutEnergy[0]*1000); 
			break;
		case TOPWAY_32BIT_ADDR_GUN_A_END_ENERGY_VALUE:
			u32Value = (UINT32)(gEvChargeInfo.fTotalOutEnergy[0]*1000); 
			break;
		case TOPWAY_32BIT_ADDR_GUN_B_CHG_ENERGY_VALUE:
			u32Value = (UINT32)(gEvChargeInfo.fTotalOutEnergy[1]*1000); 
			break;
		case TOPWAY_32BIT_ADDR_GUN_B_END_ENERGY_VALUE:
			u32Value = (UINT32)(gEvChargeInfo.fTotalOutEnergy[1]*1000); 
			break;

	}

	return u32Value;
}
#define	TOPWAY_QR_CODE_BYTES_NUMBER		106			//TOPWAY屏二维码长度
void TopwayGetStringSignal(unsigned long TopwayRegAddr, unsigned char *pString)
{	
	unsigned char i, uctemp;
	__XXX_UNION_VALUE unVal;
	__16BITS_UNION_VALUE untemp_16bits;
	UNUSED(pString);

	switch (TopwayRegAddr)
	{
		case TOPWAY_STR_ADDR_HARDWARE_VER:
			if((gEvChargeInfo.u8HardwareVer[0] < 26) && (gEvChargeInfo.u8HardwareVer[1] < 100))
			{
				*(pString+0) = 'A' + gEvChargeInfo.u8HardwareVer[0];
				sprintf( (char*)(pString+1), "%02d", gEvChargeInfo.u8HardwareVer[1]);
			}
			else
			{
				*(pString+0) = 'A';
				*(pString+1) = '0';
				*(pString+2) = '1';
			}			
			break;

		case TOPWAY_STR_ADDR_CARD_CERTIFY_ID:
			uctemp = strnlen((char const*)(gBrushInfo.u8TempCARDInfo), 16);
			strncpy((char*)pString, (const char*)(gBrushInfo.u8TempCARDInfo), uctemp);
			if(uctemp > 6)
			{
				for(i = 3; i < 7; i++)
				{
					*(pString+i) = '*';
				}
			}
			break;
		case TOPWAY_STR_ADDR_VIN_CERTIFY_ID:
			strncpy((char*)pString, (const char*)(gEvChargeInfo.u8VinCode), 17);			
			break;

		case TOPWAY_STR_ADDR_GUN_A_CARD_ID:	// //A枪 卡号
			uctemp = strnlen((const char*)gBrushInfo.u8CARDInfo[GUN_NO_A], 17);
			strncpy((char*)pString, (const char*)(gBrushInfo.u8CARDInfo[GUN_NO_A]), uctemp);
			if(uctemp > 6)
			{
				for(i = 3; i < 7; i++)
				{
					*(pString+i) = '*';
				}
			}
			break;
		case TOPWAY_STR_ADDR_GUN_A_RESERVE_ID: //预约号
			uctemp = strnlen((const char*)gs_EthAppCommMng.u8APPInfo[GUN_NO_A], 16);
			strncpy((char *)pString, (const char*)(gs_EthAppCommMng.u8APPInfo[GUN_NO_A]), uctemp);
			if(uctemp > 6)
			{
				for(i = 3; i < 7; i++)
				{
					*(pString+i) = '*';
				}
			}
			break;
		case TOPWAY_STR_ADDR_GUN_B_RESERVE_ID: //预约号
			uctemp = strnlen((const char*)(gs_EthAppCommMng.u8APPInfo[GUN_NO_B]), 16);
			strncpy((char*)pString, (const char*)(gs_EthAppCommMng.u8APPInfo[GUN_NO_B]), uctemp);
			if(uctemp > 6)
			{
				for(i = 3; i < 7; i++)
				{
					*(pString+i) = '*';
				}
			}
			break;
		case TOPWAY_STR_ADDR_GUN_A_QR_CODE_2:
			ExGetSigInfo(E_TYPE_SYS, ID_SETDATA_EVChargeCodeOnUI_NUM, &unVal, NULL, BY_E2PROM);
			if(unVal.chtemp[0] == 0)  //桩号
			{
				strncpy((char*)pString, (const char*)(gEvChargeInfo.u8EVCode), strnlen((const char*)(gEvChargeInfo.u8EVCode), 16));
			}
			else  if(unVal.chtemp[0] == 1)  //网络获取
			{
				strncpy((char*)pString, (const char*)(gs_EthAppCommMng.ucSetIdentify[0]), strnlen((const char*)(gs_EthAppCommMng.ucSetIdentify[0]), 16));
			}
			break;
		case TOPWAY_STR_ADDR_GUN_B_QR_CODE_2:
			ExGetSigInfo(E_TYPE_SYS, ID_SETDATA_EVChargeCodeOnUI_NUM, &unVal, NULL, BY_E2PROM);
			if(unVal.chtemp[0] == 0)  //桩号
			{
				strncpy((char*)pString, (const char*)(gEvChargeInfo.u8EVCode), strnlen((const char*)(gEvChargeInfo.u8EVCode), 16));
			}
			else if(unVal.chtemp[0] == 1)  //网络获取
			{
				strncpy((char*)pString, (const char*)(gs_EthAppCommMng.ucSetIdentify[1]), strnlen((const char*)(gs_EthAppCommMng.ucSetIdentify[1]), 16));
			}
			break;

		case TOPWAY_STR_ADDR_GUN_B_CARD_ID:	// //B枪 卡号
			uctemp = strnlen((const char*)(gBrushInfo.u8CARDInfo[GUN_NO_B]), 17);
			strncpy((char *)pString, (const char*)(gBrushInfo.u8CARDInfo[GUN_NO_B]), uctemp);
			if(uctemp > 6)
			{
				for(i = 3; i < 7; i++)
				{
					*(pString+i) = '*';
				}
			}
			break;

		case TOPWAY_STR_ADDR_PASSWORD:	// //密码
			strncpy((char*)pString, (const char*)TopwayPasswordBuf, strnlen((const char*)TopwayPasswordBuf, TOPWAY_PASSWORD_BUF_LENTH));
			break;

		case TOPWAY_STR_ADDR_USER1_PASSWORD:	// //密码
			strncpy((char*)pString, (const char*)gEvChargeInfo.u16UserPassword[0], strnlen((const char*)gEvChargeInfo.u16UserPassword[0], TOPWAY_PASSWORD_BUF_LENTH));
			break;
		case TOPWAY_STR_ADDR_USER2_PASSWORD:	// //密码
			strncpy((char*)pString, (const char*)gEvChargeInfo.u16UserPassword[1], strnlen((const char*)gEvChargeInfo.u16UserPassword[1], TOPWAY_PASSWORD_BUF_LENTH));
			break;
		case TOPWAY_STR_ADDR_USER3_PASSWORD:	// //密码
			//if(gs_DisplayCtrl.u8UserLevel >= 3)
			{
				strncpy((char*)pString, (const char*)gEvChargeInfo.u16UserPassword[2], strnlen((const char*)gEvChargeInfo.u16UserPassword[2], TOPWAY_PASSWORD_BUF_LENTH));
			}
			/*else
			{
				for(i = 0; i < 6; i++)
				{
					*(pString+i) = '*';
				}
			}*/
			break;

		case TOPWAY_STR_ADDR_RECORD_MAC:
			sprintf( (char*)pString, "%02X %02X %02X %02X %02X %02X", gEvChargeInfo.u8Mac[5], gEvChargeInfo.u8Mac[4],gEvChargeInfo.u8Mac[3],
						gEvChargeInfo.u8Mac[2],gEvChargeInfo.u8Mac[1],gEvChargeInfo.u8Mac[0]);
			break;

		case TOPWAY_STR_ADDR_RECORD_CARD_ID:	//充电记录 卡号
		//	strncpy((char*)pString, (char const*)(stViewChargeRecordFlash.u8CARDNo), strnlen((const char*)(stViewChargeRecordFlash.u8CARDNo), 16));
			uctemp = strnlen((char const*)(stViewChargeRecordFlash.u8CARDNo), 17);
			strncpy((char*)pString, (const char*)(stViewChargeRecordFlash.u8CARDNo), uctemp);
			if(uctemp > 6)
			{
				for(i = 3; i < 7; i++)
				{
					*(pString+i) = '*';
				}
			}
			break;
		case TOPWAY_STR_ADDR_RECORD_BILL_ID:	//充电记录 订单号
			strncpy((char*)pString, (char const*)(stViewChargeRecordFlash.u8CostNo), strnlen((const char*)(stViewChargeRecordFlash.u8CostNo), COST_NO_BYTES));
			break;

		case TOPWAY_STR_ADDR_STATION_ID:	//桩号
			strncpy((char*)pString, (char const*)(gEvChargeInfo.u8EVCode), strnlen((const char*)(gEvChargeInfo.u8EVCode), 16));
			break;
		case TOPWAY_STR_ADDR_STATION_ID_GOVERMENT:	//桩号
			strncpy((char*)pString, (char const*)(gEvChargeInfo.Server2_StationID), strnlen((const char*)(gEvChargeInfo.Server2_StationID), 16));
			break;

		case TOPWAY_STR_ADDR_GUN_A_QR_CODE:	//抢号
			ExGetSigInfo(E_TYPE_SYS, ID_SETDATA_EVChargeCodeOnUI_NUM, &unVal, NULL, BY_E2PROM);
			if(unVal.chtemp[0] == 0)  //桩号
			{
				strncpy((char*)pString, (char const*)(gEvChargeInfo.u8EVCode), strnlen((const char*)(gEvChargeInfo.u8EVCode), 16));
			}
			else if(unVal.chtemp[0] == 2)  //桩号
			{
				uctemp = strnlen((const char*)(gEvChargeInfo.u8GunASetQrCode), 50);
				strncpy((char*)pString, (char const*)(gEvChargeInfo.u8GunASetQrCode), uctemp);
			}
			else
			{
				strncpy((char*)pString, (char const*)(gs_EthAppCommMng.ucSetCodeByHost[0]), strnlen((const char*)(gs_EthAppCommMng.ucSetCodeByHost[0]), TOPWAY_QR_CODE_BYTES_NUMBER));
			}
			break;
		case TOPWAY_STR_ADDR_GUN_B_QR_CODE:	//抢号
			ExGetSigInfo(E_TYPE_SYS, ID_SETDATA_EVChargeCodeOnUI_NUM, &unVal, NULL, BY_E2PROM);
			if(unVal.chtemp[0] == 0)  //桩号
			{
				strncpy((char*)pString, (char const*)(gEvChargeInfo.u8EVCode), strnlen((const char*)(gEvChargeInfo.u8EVCode), 16));
			}
			else if(unVal.chtemp[0] == 2)  //桩号
			{
				uctemp = strnlen((const char*)(gEvChargeInfo.u8GunBSetQrCode), 50);
				strncpy((char*)pString, (char const*)(gEvChargeInfo.u8GunBSetQrCode), uctemp);
			}
			else
			{
				strncpy((char*)pString, (char const*)(gs_EthAppCommMng.ucSetCodeByHost[1]), strnlen((const char*)(gs_EthAppCommMng.ucSetCodeByHost[1]), TOPWAY_QR_CODE_BYTES_NUMBER));
			}
			break;

		case TOPWAY_STR_ADDR_DOMAIN_NAME:	//域名
			strncpy((char*)pString, (char const*)(gEvChargeInfo.u16ServerName), strnlen((const char*)(gEvChargeInfo.u16ServerName), 32));
			break;
		
		case TOPWAY_STR_ADDR_NetFrameHead:
			untemp_16bits.u16Temp = gs_EthAppCommMng.u16NetFrameHead; 
			sprintf( (char*)pString, "%02X%02X", untemp_16bits.chtemp[0], untemp_16bits.chtemp[1]);
			break;


		case TOPWAY_STR_ADDR_GUN_A_BSM_BYTE6_7:			
			sprintf( (char*)pString, "%02X %02X", gEVBms_1_Info.byEV_BSM_byte6, gEVBms_1_Info.byEV_BSM_byte7);
			break;

		case TOPWAY_STR_ADDR_GUN_B_BSM_BYTE6_7:
			sprintf( (char*)pString, "%02X %02X", gEVBms_2_Info.byEV_BSM_byte6, gEVBms_2_Info.byEV_BSM_byte7);
			break;

		case TOPWAY_STR_ADDR_GUN_A_BST_BYTES:
			untemp_16bits.u16Temp = gEVBms_1_Info.u16BST_FaultReason; 
			sprintf( (char*)pString, "%02X %02X %02X %02X", gEVBms_1_Info.u8BST_StopReason, untemp_16bits.chtemp[0], 
					untemp_16bits.chtemp[1], gEVBms_1_Info.u8BST_ErrorReason);
			break;

		case TOPWAY_STR_ADDR_GUN_B_BST_BYTES:
			untemp_16bits.u16Temp = gEVBms_2_Info.u16BST_FaultReason; 
			sprintf( (char*)pString, "%02X %02X %02X %02X", gEVBms_2_Info.u8BST_StopReason, untemp_16bits.chtemp[0], 
				untemp_16bits.chtemp[1], gEVBms_2_Info.u8BST_ErrorReason);
			break;

		case TOPWAY_STR_ADDR_RESET_REASON1:
			sprintf( (char*)pString, "%08X", gs_E2PROM.u32ResetReasonDogBit[0]);
			break;
		case TOPWAY_STR_ADDR_RESET_REASON2:
			sprintf( (char*)pString, "%08X", gs_E2PROM.u32ResetReasonDogBit[1]);
			break;
		case TOPWAY_STR_ADDR_RESET_REASON3:
			sprintf( (char*)pString, "%08X", gs_E2PROM.u32ResetReasonDogBit[2]);
			break;

		case TOPWAY_STR_ADDR_GUN_A_SET_QR_CODE:	//B枪设置二维码
			strncpy((char*)pString, (char const*)(gEvChargeInfo.u8GunASetQrCode), strnlen((const char*)(gEvChargeInfo.u8GunASetQrCode), 50));
			break;
		case TOPWAY_STR_ADDR_GUN_B_SET_QR_CODE:	//B枪设置二维码
			strncpy((char*)pString, (char const*)(gEvChargeInfo.u8GunBSetQrCode), strnlen((const char*)(gEvChargeInfo.u8GunBSetQrCode), 50));
			break;

		default:

			break;
	}

	
}

//unsigned char is32BitParas  0-16bits 1-32bits
void  TopwaySetCfgSignal(unsigned long TopwayRegAddr, UINT32 u32Value, unsigned char is32BitParas)
{
	__XXX_UNION_VALUE unTemp;
	__XXX_UNION_VALUE unVal;
	unsigned char u8SigType;
	unsigned short ii;
	float fRatio;

	//充电中禁止修改辅助电源电压
	if(TopwayRegAddr == TOPWAY_16BIT_ADDR_PARA_GUN_A_BMS_VOLT_SEL)
	{
		if (gEvChargeInfo.u8_Charge_CMD[GUN_NO_A] == START_CHARGE_VAL)
		{
			return;
		}
	}
	//充电中禁止修改辅助电源电压
	if(TopwayRegAddr == TOPWAY_16BIT_ADDR_PARA_GUN_B_BMS_VOLT_SEL)
	{
		if (gEvChargeInfo.u8_Charge_CMD[GUN_NO_B] == START_CHARGE_VAL)
		{
			return;
		}
	}
	//充电中禁止修改并机模式
	if ((gEvChargeInfo.u8_Charge_CMD[GUN_NO_A] == START_CHARGE_VAL)
		||(gEvChargeInfo.u8_Charge_CMD[GUN_NO_B] == START_CHARGE_VAL)	
		||((gs_CANComm.bIsRingEnabled == TRUE)
			&& (g_pRing_A->pNodeMe->emLockState == _LOCK_AS_SLAVE || g_pRing_B->pNodeMe->emLockState == _LOCK_AS_SLAVE))
			)
	{
		if((TopwayRegAddr == TOPWAY_16BIT_ADDR_PARA_SYS_PARALL_MODE)
			|| (TopwayRegAddr == TOPWAY_16BIT_ADDR_PARA_SYS_RING_EN)
			|| (TopwayRegAddr == TOPWAY_16BIT_ADDR_PARA_SYS_RING_MODE)
			|| (TopwayRegAddr == TOPWAY_16BIT_ADDR_PARA_SYS_IS_SINGLE_GUN_MODE))
		{
			return;
		}
	}

	//单双枪模式的修改需要密码等级为3
	if(((TopwayRegAddr == TOPWAY_16BIT_ADDR_PARA_SYS_IS_SINGLE_GUN_MODE)
		|| (TopwayRegAddr == TOPWAY_32BIT_ADDR_PARA_DC_METER_RATIO)
		|| (TopwayRegAddr == TOPWAY_16BIT_ADDR_PARA_SYS_u8ButtonChgEn))
		&& (gs_DisplayCtrl.u8UserLevel < 3))
	{
		return;
	}
	


	//因为网络屏蔽参数会影响刷卡逻辑，为了防止刷卡启动充电后又去修改这个逻辑，所以只能允许在待机状态下修改本参数
	if(TopwayRegAddr == TOPWAY_16BIT_ADDR_PARA_SYS_NET_MASK)
	{
		if((gs_DisplayCtrl.u8GunDispStat[0] != GUN_DISP_STAT_Standby)
			|| (gs_DisplayCtrl.u8GunDispStat[1] != GUN_DISP_STAT_Standby))
		{
			return;
		}
	}
	

	for(ii = 0; ii < s_u16DispSigMapNum; ii++)
	{
		if(s_DispSigMap[ii].u32DispSigAddr == TopwayRegAddr)			
		{
			unTemp = unionGetE2pVal(s_DispSigMap[ii].u8Etype, s_DispSigMap[ii].u16Idx, &u8SigType);

			/*if((TopwayRegAddr >= TOPWAY_32BIT_FEE_PARA_ADDR_RANGE_START) && (TopwayRegAddr <= TOPWAY_32BIT_FEE_PARA_ADDR_RANGE_END))
			{

			}*/

			if(u8SigType == IS_CHAR)
			{
				unVal.chtemp[0] = u32Value;
			}
			else if(u8SigType == IS_FLOAT)
			{
				switch(s_DispSigMap[ii].u8Ratio)
				{
					case DISP_RATIO_X10:
						fRatio = 0.1;
						break;
					case DISP_RATIO_X100:
						fRatio = 0.01;
						break;
					case DISP_RATIO_X1000:
						fRatio = 0.001;
						break;
					case DISP_RATIO_X10000:
						fRatio = 0.0001;
						break;
					default:
						fRatio = 1;
						break;
				}

				if(is32BitParas == 1)  //屏上定义的是浮点参数
				{
					unTemp.u32Value = u32Value;

					unVal.ftemp = unTemp.ftemp * fRatio;
				}
				else  //16bits   屏上定义的是16位整数
				{
					fRatio = fRatio*u32Value;					
					unVal.ftemp = fRatio;
				}
			}
			else if(u8SigType == IS_ULONG)
			{
				switch(s_DispSigMap[ii].u8Ratio)
				{
					case DISP_RATIO_X10:
						fRatio = 0.1;
						break;
					case DISP_RATIO_X100:
						fRatio = 0.01;
						break;
					case DISP_RATIO_X1000:
						fRatio = 0.001;
						break;
					case DISP_RATIO_X10000:
						fRatio = 0.0001;
						break;
					default:
						fRatio = 1;
						break;
				}

				fRatio *= u32Value;
				unVal.u32Value = (UINT32)fRatio;
			}
			else
			{
				return;
			}

			ExSetSigInfo(s_DispSigMap[ii].u8Etype, s_DispSigMap[ii].u16Idx, unVal, NULL, BY_E2PROM);
		}
	}
}

void  TopwaySetSysTime(unsigned long TopwayRegAddr, unsigned short u16Value)
{
	/*__XXX_UNION_VALUE unTemp;
	__XXX_UNION_VALUE unVal;
	unsigned char u8SigType;
	unsigned short ii;
	float fRatio;*/
	struct tm  tmNow;
	unsigned char ucFlag;


	ucFlag = FALSE;

	gRTCData.fGetLocalTime(&tmNow);

	switch(TopwayRegAddr)
	{
		case TOPWAY_16BIT_ADDR_SYSTEM_TIME_Y:// = 0x00080104,			//系统时间 年
			if(tmNow.tm_year != u16Value)
			{
				tmNow.tm_year = u16Value;
				ucFlag = TRUE;
			}
			break;

		case TOPWAY_16BIT_ADDR_SYSTEM_TIME_MON:// = 0x00080106,			//系统时间 月
			if(tmNow.tm_mon != u16Value)
			{
				tmNow.tm_mon = u16Value;
				ucFlag = TRUE;
			}
			break;

		case TOPWAY_16BIT_ADDR_SYSTEM_TIME_D:// = 0x00080108,			//系统时间 日
			if(tmNow.tm_mday != u16Value)
			{
				tmNow.tm_mday = u16Value;
				ucFlag = TRUE;
			}
			break;

		case TOPWAY_16BIT_ADDR_SYSTEM_TIME_H:// = 0x0008010A,			//系统时间 时
			if(tmNow.tm_hour != u16Value)
			{
				tmNow.tm_hour = u16Value;
				ucFlag = TRUE;
			}
			break;

		case TOPWAY_16BIT_ADDR_SYSTEM_TIME_MIN:// = 0x0008010C,			//系统时间 分
			if(tmNow.tm_min != u16Value)
			{
				tmNow.tm_min = u16Value;
				ucFlag = TRUE;
			}
			break;

		case TOPWAY_16BIT_ADDR_SYSTEM_TIME_S:// = 0x0008010E,			//系统时间 秒
			if(tmNow.tm_sec != u16Value)
			{
				tmNow.tm_sec = u16Value;
				ucFlag = TRUE;
			}
			break;

		default:
			break;

	}

	if(ucFlag == TRUE)
	{
		gRTCData.fSetLocalTime(&tmNow);
	}
}



void GetRecordDeal(unsigned char u8InputFlag)
{
	//struct tm timeNow;
	INT32 CSecond = 0;
	unsigned char u8Idx;

	if(u8InputFlag == GetRecordDeal_Init)
	{
		if (gChargeLogTable.u32TotalNum > 1)
		{
			gFlashOptInfo.u32ViewRecordNo = gChargeLogTable.u32TotalNum;
		}
		else
		{
			gFlashOptInfo.u32ViewRecordNo = 1;
		}
	}
	else if(u8InputFlag == GetRecordDeal_Next)
	{
		gFlashOptInfo.u32ViewRecordNo++;
		if (gFlashOptInfo.u32ViewRecordNo > (gChargeLogTable.u32TotalNum))
		{
			if(gChargeLogTable.u32TotalNum > MAX_RECORD_NUMBER)
			{
				gFlashOptInfo.u32ViewRecordNo = gChargeLogTable.u32TotalNum - MAX_RECORD_NUMBER + 1;
			}
			else
			{
				gFlashOptInfo.u32ViewRecordNo = 1;
			}
		}
	}
	else if(u8InputFlag == GetRecordDeal_Prev)
	{
		if (gChargeLogTable.u32TotalNum > 0)
		{
			gFlashOptInfo.u32ViewRecordNo--;
		}

		if(gChargeLogTable.u32TotalNum > MAX_RECORD_NUMBER)
		{
			if(gFlashOptInfo.u32ViewRecordNo <= (gChargeLogTable.u32TotalNum - MAX_RECORD_NUMBER))
			{
				gFlashOptInfo.u32ViewRecordNo = gChargeLogTable.u32TotalNum;
			}
		}
		else if (gFlashOptInfo.u32ViewRecordNo < 1)
		{
			if (gChargeLogTable.u32TotalNum > 1)
			{
				gFlashOptInfo.u32ViewRecordNo = gChargeLogTable.u32TotalNum;
			}
			else
			{
				gFlashOptInfo.u32ViewRecordNo = 1;
			}
		}
	}	

	gFlashOptInfo.u32ViewPageIdx = FLASH_GetPageIdx(gFlashOptInfo.u32ViewRecordNo);
	FLASH_ReadRecords(gFlashOptInfo.u32ViewPageIdx*BYTES_NUM_PER_PAGE, &stViewChargeRecordFlash.u8SpearType,sizeof(stViewChargeRecordFlash)/sizeof(UINT8));
	memset(ViewCostBuf, 0, sizeof(ViewCostBuf));
	for (u8Idx = 0; u8Idx < COST_NO_BYTES; u8Idx++)
	{
		ViewCostBuf[u8Idx] = stViewChargeRecordFlash.u8CostNo[u8Idx];
	}
	/*timeNow.tm_year = stViewChargeRecordFlash.StopTime.tm_year - YEAR0;
	timeNow.tm_mon = stViewChargeRecordFlash.StopTime.tm_mon;
	timeNow.tm_mday = stViewChargeRecordFlash.StopTime.tm_mday;
	timeNow.tm_hour = stViewChargeRecordFlash.StopTime.tm_hour;
	timeNow.tm_min = stViewChargeRecordFlash.StopTime.tm_min;
	timeNow.tm_sec = stViewChargeRecordFlash.StopTime.tm_sec;
	now = mktime_r(&timeNow);
	timeNow.tm_year = stViewChargeRecordFlash.StartTime.tm_year - YEAR0;
	timeNow.tm_mon = stViewChargeRecordFlash.StartTime.tm_mon;
	timeNow.tm_mday = stViewChargeRecordFlash.StartTime.tm_mday;
	timeNow.tm_hour = stViewChargeRecordFlash.StartTime.tm_hour;
	timeNow.tm_min = stViewChargeRecordFlash.StartTime.tm_min;
	timeNow.tm_sec = stViewChargeRecordFlash.StartTime.tm_sec;
	now2 = mktime_r(&timeNow);
	CSecond = now - now2;
	if (CSecond <= 0)
	{
		CSecond = 0;
	}*/
	CSecond = stViewChargeRecordFlash.u32ChargeTotalTime;

	ViewHour = CSecond/3600;
	ViewMin = (CSecond - (ViewHour*3600))/60;
	ViewSec = CSecond%60;

}

void  TopwaySetAdjustSignal(unsigned long TopwayRegAddr, UINT32 u32Value)
{
	__XXX_UNION_VALUE unTemp;
	//__XXX_UNION_VALUE unVal;
	//unsigned char u8SigType;
	//unsigned short ii;
	//float fRatio;
        void *PEInfo;

	unTemp.u32Value = u32Value;

	switch(TopwayRegAddr)
	{
		case TOPWAY_32BIT_ADDR_GUN_A_ADJUST_REQ_VOLT:
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			((stBMS_INFO*)PEInfo)->fBMSRequireVolt = unTemp.ftemp;
			gs_CANComm.fSetRectCtlVoltCurr(GRP_A, ((stBMS_INFO*)PEInfo)->fBMSRequireVolt, ((stBMS_INFO*)PEInfo)->fBMSRequireCurr);
			break;

		case TOPWAY_32BIT_ADDR_GUN_A_ADJUST_REQ_CURR:
			PEInfo = GetgEquipInfo(E_TYPE_BMS1);
			((stBMS_INFO*)PEInfo)->fBMSRequireCurr = unTemp.ftemp;
			gs_CANComm.fSetRectCtlVoltCurr(GRP_A, ((stBMS_INFO*)PEInfo)->fBMSRequireVolt, ((stBMS_INFO*)PEInfo)->fBMSRequireCurr);
			break;

		case TOPWAY_32BIT_ADDR_GUN_B_ADJUST_REQ_VOLT:
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			((stBMS_INFO*)PEInfo)->fBMSRequireVolt = unTemp.ftemp;
			gs_CANComm.fSetRectCtlVoltCurr(GRP_B, ((stBMS_INFO*)PEInfo)->fBMSRequireVolt, ((stBMS_INFO*)PEInfo)->fBMSRequireCurr);
			break;

		case TOPWAY_32BIT_ADDR_GUN_B_ADJUST_REQ_CURR:
			PEInfo = GetgEquipInfo(E_TYPE_BMS2);
			((stBMS_INFO*)PEInfo)->fBMSRequireCurr = unTemp.ftemp;
			gs_CANComm.fSetRectCtlVoltCurr(GRP_B, ((stBMS_INFO*)PEInfo)->fBMSRequireVolt, ((stBMS_INFO*)PEInfo)->fBMSRequireCurr);
			break;


		case TOPWAY_32BIT_ADDR_GUN_A_ADJUST_IN_A_REALVOLT:					
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			((EV_CHARGE_INFO*)PEInfo)->fBattSet_A_Volt = unTemp.ftemp;
			((EV_CHARGE_INFO*)PEInfo)->u8Batt_1VoltSet_A_Flag = TRUE;
			break;
		case TOPWAY_32BIT_ADDR_GUN_A_ADJUST_IN_B_REALVOLT:					
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			((EV_CHARGE_INFO*)PEInfo)->fBattSet_B_Volt = unTemp.ftemp;
			((EV_CHARGE_INFO*)PEInfo)->u8Batt_1VoltSet_B_Flag = TRUE;
			break;

		case TOPWAY_32BIT_ADDR_GUN_B_ADJUST_IN_A_REALVOLT:					
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			((EV_CHARGE_INFO*)PEInfo)->fBattSet_A_Volt = unTemp.ftemp;
			((EV_CHARGE_INFO*)PEInfo)->u8Batt_2VoltSet_A_Flag = TRUE;
			break;
		case TOPWAY_32BIT_ADDR_GUN_B_ADJUST_IN_B_REALVOLT:					
			PEInfo = GetgEquipInfo(E_TYPE_SYS);
			((EV_CHARGE_INFO*)PEInfo)->fBattSet_B_Volt = unTemp.ftemp;
			((EV_CHARGE_INFO*)PEInfo)->u8Batt_2VoltSet_B_Flag = TRUE;
			break;
	}

}

void  TopwayDebugAction(UINT8 u8ActionRelay, UINT16 u16Value)
{
	if(gEvChargeInfo.u8TEST_MODE_FLAG == FALSE)
	{
		return;
	}

	switch(u8ActionRelay)
	{
		case DEBUG_MCCB_A:  //TOPWAY_16BIT_ADDR_DEBUG_MCCB_A:// = 0x00080BC2,		//调测控制 A枪接触器
			//if(gEvChargeInfo.u8TEST_MODE_FLAG == TRUE)
			{
				if(u16Value == 1)
				{
					__A_DC_MCCB_ON();
				}
				else
				{
					__A_DC_MCCB_OFF();
				}
				gEvChargeInfo.u8DebugSig[DEBUG_MCCB_A] = u16Value;
			}
			break;

		case DEBUG_BMS_12V_A:  //TOPWAY_16BIT_ADDR_DEBUG_BMS_12V_A:// = 0x00080BC4,		//调测控制 A枪辅助电源
			//if(gEvChargeInfo.u8TEST_MODE_FLAG == TRUE)
			{
				if(u16Value == 1)
				{
					__BMS_1_POWER_ON();
				}
				else
				{
					__BMS_1_POWER_OFF();
				}
				gEvChargeInfo.u8DebugSig[DEBUG_BMS_12V_A] = u16Value;
			}
			break;

		case DEBUG_LOCK_A:  //TOPWAY_16BIT_ADDR_DEBUG_LOCK_A:// = 0x00080BC6,		//调测控制 A枪锁
			//if(gEvChargeInfo.u8TEST_MODE_FLAG == TRUE)
			{
				if(u16Value == 1)
				{
					__A_SPEAR_LOCK();
				}
				else
				{
					__A_SPEAR_UNLOCK();
				}
				gEvChargeInfo.u8DebugSig[DEBUG_LOCK_A] = u16Value;
			}
			break;

		case DEBUG_ALARM_LIGHT_A: //TOPWAY_16BIT_ADDR_DEBUG_ALARM_LIGHT_A:// = 0x00080BC8,	//调测控制 A枪告警灯
			//if(gEvChargeInfo.u8TEST_MODE_FLAG == TRUE)
			{
				if(u16Value == 1)
				{
					__A_RED_LED_ON();
				}
				else
				{
					__A_RED_LED_OFF();
				}
				gEvChargeInfo.u8DebugSig[DEBUG_ALARM_LIGHT_A] = u16Value;
			}
			break;

		case DEBUG_CHG_LIGHT_A: //TOPWAY_16BIT_ADDR_DEBUG_CHG_LIGHT_A:// = 0x00080BCA,	//调测控制 A枪充电灯
			//if(gEvChargeInfo.u8TEST_MODE_FLAG == TRUE)
			{
				if(u16Value == 1)
				{
					__A_YELLOW_LED_ON();
				}
				else
				{
					__A_YELLOW_LED_OFF();
				}
				gEvChargeInfo.u8DebugSig[DEBUG_CHG_LIGHT_A] = u16Value;
			}
			break;

		case DEBUG_RING_RELAY_A: //TOPWAY_16BIT_ADDR_DEBUG_RING_RELAY_A:// = 0x00080BCC,	//调测控制 并机接触器
			//if(gEvChargeInfo.u8TEST_MODE_FLAG == TRUE)
			{
				if(u16Value == 1)
				{
					__PARALLEL_ON();
				}
				else
				{
					__PARALLEL_OFF();
				}
				gEvChargeInfo.u8DebugSig[DEBUG_RING_RELAY_A] = u16Value;
			}
			break;

		case DEBUG_MCCB_B: //TOPWAY_16BIT_ADDR_DEBUG_MCCB_B:// = 0x00080BCE,		//调测控制 B枪接触器
			//if(gEvChargeInfo.u8TEST_MODE_FLAG == TRUE)
			{
				if(u16Value == 1)
				{
					__B_DC_MCCB_ON();
				}
				else
				{
					__B_DC_MCCB_OFF();
				}
				gEvChargeInfo.u8DebugSig[DEBUG_MCCB_B] = u16Value;
			}
			break;
		case DEBUG_BMS_12V_B: //TOPWAY_16BIT_ADDR_DEBUG_BMS_12V_B:// = 0x00080BD0,		//调测控制 B枪辅助电源
			//if(gEvChargeInfo.u8TEST_MODE_FLAG == TRUE)
			{
				if(u16Value == 1)
				{
					__BMS_2_POWER_ON();
				}
				else
				{
					__BMS_2_POWER_OFF();
				}
				gEvChargeInfo.u8DebugSig[DEBUG_BMS_12V_B] = u16Value;
			}
			break;

		case DEBUG_LOCK_B: //TOPWAY_16BIT_ADDR_DEBUG_LOCK_B:// = 0x00080B2,			//调测控制 B枪锁
			//if(gEvChargeInfo.u8TEST_MODE_FLAG == TRUE)
			{
				if(u16Value == 1)
				{
					__B_SPEAR_LOCK();
				}
				else
				{
					__B_SPEAR_UNLOCK();
				}
				gEvChargeInfo.u8DebugSig[DEBUG_LOCK_B] = u16Value;
			}
			break;
		case DEBUG_ALARM_LIGHT_B: //TOPWAY_16BIT_ADDR_DEBUG_ALARM_LIGHT_B:// = 0x00080BD4,	//调测控制 B枪告警灯
			//if(gEvChargeInfo.u8TEST_MODE_FLAG == TRUE)
			{
				if(u16Value == 1)
				{
					//__B_RED_LED_ON();
					//__ACINPUT_MCCB_ON();

					BSP_DO_Ctrl(NEWDO16, DO_ON);
				}
				else
				{
					//__B_RED_LED_OFF();
					//__ACINPUT_MCCB_OFF();
					BSP_DO_Ctrl(NEWDO16, DO_OFF);
				}
				gEvChargeInfo.u8DebugSig[DEBUG_ALARM_LIGHT_B] = u16Value;
			}
			break;

		case DEBUG_CHG_LIGHT_B: //TOPWAY_16BIT_ADDR_DEBUG_CHG_LIGHT_B:// = 0x00080BD6,	//调测控制 B枪充电灯
			//if(gEvChargeInfo.u8TEST_MODE_FLAG == TRUE)
			{
				if(u16Value == 1)
				{
					__B_YELLOW_LED_ON();
				}
				else
				{
					__B_YELLOW_LED_OFF();
				}
				gEvChargeInfo.u8DebugSig[DEBUG_CHG_LIGHT_B] = u16Value;
			}
			break;
		case DEBUG_RING_RELAY_B: //TOPWAY_16BIT_ADDR_DEBUG_RING_RELAY_B:// = 0x00080BD8,	//调测控制 环网接触器
			//if(gEvChargeInfo.u8TEST_MODE_FLAG == TRUE)
			{
				if(u16Value == 1)
				{
					gEvChargeInfo.u8CTRLInterDOCMD = 0x01;
				}
				else
				{
					gEvChargeInfo.u8CTRLInterDOCMD = 0x00;
				}
				gEvChargeInfo.u8CTRLInterDOCMDFlag = TRUE;
				gEvChargeInfo.u8DebugSig[DEBUG_RING_RELAY_B] = u16Value;
			}
			break;

		case DEBUG_AC_FAN: //TOPWAY_16BIT_ADDR_DEBUG_AC_FAN:// = 0x00080BDA,		//调测控制 交流风扇
			//if(gEvChargeInfo.u8TEST_MODE_FLAG == TRUE)
			{
				if(u16Value == 1)
				{
					__FAN_ON();
					gEvChargeInfo.u8CTRLInterDOCMD_B = 0x01;
				}
				else
				{
					__FAN_OFF();
					gEvChargeInfo.u8CTRLInterDOCMD_B = 0x00;
				}
				gEvChargeInfo.u8CTRLInterDOCMDFlag_B = TRUE;
				gEvChargeInfo.u8DebugSig[DEBUG_AC_FAN] = u16Value;
			}
			break;

		case DEBUG_DC_FAN: // TOPWAY_16BIT_ADDR_DEBUG_DC_FAN:// = 0x00080BDC,		//调测控制 直流风扇
			//if(gEvChargeInfo.u8TEST_MODE_FLAG == TRUE)
			{		
				gEvChargeInfo.u8DebugSig[DEBUG_DC_FAN] = u16Value;
				dv_Capture_PWM.fOutputFanDriver(mFAN1,u16Value);
			}
			break;

		default:
			break;
	}
}
void  TopwayDebugSignal(unsigned long TopwayRegAddr, UINT16 u16Value)
{
	unsigned char i;

	switch(TopwayRegAddr)
	{		
		case TOPWAY_16BIT_ADDR_DEBUG_ONOFF: // = 0x00080BC0,			//调测控制 开关状态
			if((u16Value == 1) 
				&&(gEvChargeInfo.u8_Charge_CMD[GUN_NO_A] == STOP_CHARGE_VAL)
				&& (gEvChargeInfo.u8_Charge_CMD[GUN_NO_B] == STOP_CHARGE_VAL)
				&& (gEvChargeInfo.u8DebugSig[DEBUG_ONOFF] == 0)
				&& (gs_DisplayCtrl.u8UserLevel >= 3))
			{
				gEvChargeInfo.u8DebugSig[DEBUG_ONOFF] = 1;				
				for(i = DEBUG_MCCB_A; i < DEBUG_SIG_MAX; i++)
				{
					gEvChargeInfo.u8DebugSig[i] = 0;
				}
				gEvChargeInfo.u8TEST_MODE_FLAG = TRUE;
			}
			else if((u16Value == 0)
				&& (gEvChargeInfo.u8DebugSig[DEBUG_ONOFF] == 1))
			{					
				for(i = DEBUG_MCCB_A; i < DEBUG_DC_FAN; i++)
				{
					if(gEvChargeInfo.u8DebugSig[i] != 0)
					{
						TopwayDebugAction(i, 0);
					}
				}
				gEvChargeInfo.u8DebugSig[DEBUG_ONOFF] = 0;
				gEvChargeInfo.u8DebugSig[DEBUG_QUIT_DEBUG_EN] = 1;
				gEvChargeInfo.u8TEST_MODE_FLAG = FALSE;
			}
			break;

		case TOPWAY_16BIT_ADDR_DEBUG_MCCB_A:// = 0x00080BC2,		//调测控制 A枪接触器			
			TopwayDebugAction(DEBUG_MCCB_A, u16Value);
			break;

		case TOPWAY_16BIT_ADDR_DEBUG_BMS_12V_A:// = 0x00080BC4,		//调测控制 A枪辅助电源
			TopwayDebugAction(DEBUG_BMS_12V_A, u16Value);
			break;

		case TOPWAY_16BIT_ADDR_DEBUG_LOCK_A:// = 0x00080BC6,		//调测控制 A枪锁
			TopwayDebugAction(DEBUG_LOCK_A, u16Value);
			break;

		case TOPWAY_16BIT_ADDR_DEBUG_ALARM_LIGHT_A:// = 0x00080BC8,	//调测控制 A枪告警灯
			TopwayDebugAction(DEBUG_ALARM_LIGHT_A, u16Value);
			break;

		case TOPWAY_16BIT_ADDR_DEBUG_CHG_LIGHT_A:// = 0x00080BCA,	//调测控制 A枪充电灯	
			TopwayDebugAction(DEBUG_CHG_LIGHT_A, u16Value);
			break;

		case TOPWAY_16BIT_ADDR_DEBUG_RING_RELAY_A:// = 0x00080BCC,	//调测控制 并机接触器		
			TopwayDebugAction(DEBUG_RING_RELAY_A, u16Value);
			break;

		case TOPWAY_16BIT_ADDR_DEBUG_MCCB_B:// = 0x00080BCE,		//调测控制 B枪接触器			
			TopwayDebugAction(DEBUG_MCCB_B, u16Value);
			break;
		case TOPWAY_16BIT_ADDR_DEBUG_BMS_12V_B:// = 0x00080BD0,		//调测控制 B枪辅助电源		
			TopwayDebugAction(DEBUG_BMS_12V_B, u16Value);
			break;

		case TOPWAY_16BIT_ADDR_DEBUG_LOCK_B:// = 0x00080B2,			//调测控制 B枪锁
			TopwayDebugAction(DEBUG_LOCK_B, u16Value);
			break;
		case TOPWAY_16BIT_ADDR_DEBUG_ALARM_LIGHT_B:// = 0x00080BD4,	//调测控制 B枪告警灯
			TopwayDebugAction(DEBUG_ALARM_LIGHT_B, u16Value);
			break;

		case TOPWAY_16BIT_ADDR_DEBUG_CHG_LIGHT_B:// = 0x00080BD6,	//调测控制 B枪充电灯			
			TopwayDebugAction(DEBUG_CHG_LIGHT_B, u16Value);
			break;
		case TOPWAY_16BIT_ADDR_DEBUG_RING_RELAY_B:// = 0x00080BD8,	//调测控制 环网接触器
			TopwayDebugAction(DEBUG_RING_RELAY_B, u16Value);
			break;

		case TOPWAY_16BIT_ADDR_DEBUG_AC_FAN:// = 0x00080BDA,		//调测控制 交流风扇
			TopwayDebugAction(DEBUG_AC_FAN, u16Value);
			break;

		case TOPWAY_16BIT_ADDR_DEBUG_DC_FAN:// = 0x00080BDC,		//调测控制 直流风扇
			TopwayDebugAction(DEBUG_DC_FAN, u16Value);
			break;
		default:
			break;
	}	
}

void AutoAdjustDeal(void)
{
	struct tm  tmNow;	
	//void *PEInfo;
	unsigned char  ucAdjustMode;
	//UINT16 u16Value;
	__XXX_UNION_VALUE untemp;
	//float fVolt1,fVolt2;
	static UINT8 su8Sec = 0xff;
	static UINT8 su8SecDelay = 0;

	//20190923
	if((gEvChargeInfo.u8ACInputContactorCtrlStat == DO_OFF)	
		|| (gEvChargeInfo.u8ACInputContactorCloseAlmDelayFlag == TRUE))
	{
		return;
	}

	ExGetSigInfo(E_TYPE_SYS, ID_SETDATA_AdjustMode_NUM, &untemp, NULL, BY_E2PROM);
	ucAdjustMode = untemp.chtemp[0];

	//绝缘校准
	if(gEvChargeInfo.u8AdjustHall2Flag == TRUE)
	{
		gRTCData.fGetLocalTime(&tmNow);	
		if (su8Sec != tmNow.tm_sec)
		{				
			su8Sec = tmNow.tm_sec;
			
			if(gEvChargeInfo.u8_ManualTestStep < 255)
				gEvChargeInfo.u8_ManualTestStep++;
		}
		if(gEvChargeInfo.u8_ManualTestStep == 2)  
		{
			gs_CANComm.fSetRectCtlVoltCurr(GRP_A, 0, 0);
			gs_CANComm.fSetRectCtlStatus(GRP_A, RECT_OFF);
			__A_DC_MCCB_OFF();
			gEvChargeInfo.u8_ManualTestStep = 3;
		}
		else if(gEvChargeInfo.u8_ManualTestStep == 5)
		{
			gEvChargeInfo.fHallVolt_Zero = gEvChargeInfo.fHallVolt;

			__A_DC_MCCB_ON();
			gs_CANComm.fSetRectCtlVoltCurr(GRP_A, gEVBms_1_Info.fBMSRequireVolt, gEVBms_1_Info.fBMSRequireCurr);
			gs_CANComm.fSetRectCtlStatus(GRP_A, RECT_ON);
			gEvChargeInfo.u8_ManualTestStep = 6;
		}
		else if(gEvChargeInfo.u8_ManualTestStep == 20)
		{
			gEvChargeInfo.u8AdjustHall2Flag_2 = TRUE;
			gEvChargeInfo.u8_ManualTestStep = 21;
		}
		else if(gEvChargeInfo.u8_ManualTestStep > 21)
		{
			if((gEvChargeInfo.u8AdjustHall2Flag_2 == FALSE)
				|| (gEvChargeInfo.u8_ManualTestStep > 44)) 
			{				
				gEvChargeInfo.u8AdjustHall2Flag_2 = FALSE;

				gs_CANComm.fSetRectCtlVoltCurr(GRP_A, 0, 0);
				gs_CANComm.fSetRectCtlStatus(GRP_A, RECT_OFF);
				__A_DC_MCCB_OFF();

				gEvChargeInfo.u8_ManualTestStep = 0;
				gEvChargeInfo.u8TestMode[GUN_NO_A] = FALSE;

				if(gEvChargeInfo.u8AdjustHall2Result == 0)
				{
					gEvChargeInfo.u8AdjustHall2Result = 2;  //失败
				}

				gEvChargeInfo.u8AdjustHall2Flag = 0;
			}
		}

		return;
	}//end: if(gEvChargeInfo.u8AdjustHall2Flag == TRUE)

	if(ucAdjustMode == 1)  //手动校准模式
	{
		//目的：gEvChargeInfo.u8TestMode[GUN_NO_A]或gEvChargeInfo.u8TestMode[GUN_NO_B]刚置位，需要让ALM、CAN1、CAN2任务终止
		//      增加此延时，可以保证以下模块控制、接触器控制不会冲突
		if(gEvChargeInfo.u8_ManualTestStep > 0)
		{	
			gRTCData.fGetLocalTime(&tmNow);	
			if (su8Sec != tmNow.tm_sec)
			{				
				su8Sec = tmNow.tm_sec;
				su8SecDelay++;
			}
			if(su8SecDelay > 2)
			{
				su8SecDelay = 0;
				gEvChargeInfo.u8_ManualTestStep = 0;
				gEvChargeInfo.fBattSet_A_Volt = 0;
				gEvChargeInfo.fBattSet_B_Volt = 0;

				if(gEvChargeInfo.u8TestMode[GUN_NO_B] == TRUE)
				{					
					gs_CANComm.fSetRectCtlVoltCurr(GRP_B, gEVBms_2_Info.fBMSRequireVolt, gEVBms_2_Info.fBMSRequireCurr);
					gs_CANComm.fSetRectCtlStatus(GRP_B, RECT_ON);
					__B_DC_MCCB_ON();
				}
				else //if(gEvChargeInfo.u8TestMode[GUN_NO_A] == TRUE)
				{
					gs_CANComm.fSetRectCtlVoltCurr(GRP_A, gEVBms_1_Info.fBMSRequireVolt, gEVBms_1_Info.fBMSRequireCurr);
					gs_CANComm.fSetRectCtlStatus(GRP_A, RECT_ON);
					__A_DC_MCCB_ON();
				}
			
			}
		}
		else
		{
			su8SecDelay = 0;
		}

		return;
	}

	if(gEvChargeInfo.u8_AutoTestStep > 0)
	{		
		gRTCData.fGetLocalTime(&tmNow);		

		if(gEvChargeInfo.u8_AutoTestStep == 1)  //第一步，让模块输出电压A
		{
			if (su8Sec != tmNow.tm_sec)
			{				
				su8Sec = tmNow.tm_sec;
				su8SecDelay++;
			}

			//目的：gEvChargeInfo.u8TestMode[GUN_NO_A]或gEvChargeInfo.u8TestMode[GUN_NO_B]刚置位，需要让ALM、CAN1、CAN2任务终止
			//      增加此延时，可以保证以下模块控制、接触器控制不会冲突
			if(su8SecDelay > 2)
			{
				su8SecDelay = 0;

				ExGetSigInfo(E_TYPE_SYS, ID_SETDATA_Adjust_Volt1, &untemp, NULL, BY_E2PROM);
				if (gEvChargeInfo.u8TestMode[GUN_NO_A] == TRUE) 
				{
					gEVBms_1_Info.fBMSRequireVolt = untemp.ftemp;
					gEVBms_1_Info.fBMSRequireCurr = 10;
					gs_CANComm.fSetRectCtlVoltCurr(GRP_A, gEVBms_1_Info.fBMSRequireVolt, gEVBms_1_Info.fBMSRequireCurr);
					gs_CANComm.fSetRectCtlStatus(GRP_A, RECT_ON);
					__A_DC_MCCB_ON();
				}
				else if (gEvChargeInfo.u8TestMode[GUN_NO_B] == TRUE) 
				{				
					gEVBms_2_Info.fBMSRequireVolt = untemp.ftemp;
					gEVBms_2_Info.fBMSRequireCurr = 10;
					gs_CANComm.fSetRectCtlVoltCurr(GRP_B, gEVBms_2_Info.fBMSRequireVolt, gEVBms_2_Info.fBMSRequireCurr);
					gs_CANComm.fSetRectCtlStatus(GRP_B, RECT_ON);
					__B_DC_MCCB_ON();
				}
				gEvChargeInfo.u8_AutoTestStep++;
				gEvChargeInfo.fBattSet_A_Volt = 0;
				gEvChargeInfo.fBattSet_B_Volt = 0;
			}
		}
		else if(gEvChargeInfo.u8_AutoTestStep > 1)
		{			
			if (su8Sec != tmNow.tm_sec)
			{				
				su8Sec = tmNow.tm_sec;
				gEvChargeInfo.u8_AutoTestStep++;				

				if(gEvChargeInfo.u8_AutoTestStep == 12)	  //第二步，10秒后记录下电压A实测值，用模块上报电压替代
				{
					if (gEvChargeInfo.u8TestMode[GUN_NO_A] == TRUE) 
					{						
						gEvChargeInfo.fBattSet_A_Volt = gs_CANComm.GrpData[GRP_A].fOutVolt;
						gEvChargeInfo.u8Batt_1VoltSet_A_Flag = TRUE;					
					}
					else if (gEvChargeInfo.u8TestMode[GUN_NO_B] == TRUE) 
					{
						gEvChargeInfo.fBattSet_A_Volt = gs_CANComm.GrpData[GRP_B].fOutVolt;
						gEvChargeInfo.u8Batt_2VoltSet_A_Flag = TRUE;
					}
				}
				else if(gEvChargeInfo.u8_AutoTestStep == 14)//第三步，让模块输出电压B	
				{
					ExGetSigInfo(E_TYPE_SYS, ID_SETDATA_Adjust_Volt2, &untemp, NULL, BY_E2PROM);

					if (gEvChargeInfo.u8TestMode[GUN_NO_A] == TRUE) 
					{						
						gEVBms_1_Info.fBMSRequireVolt = untemp.ftemp;
						gEVBms_1_Info.fBMSRequireCurr = 10;
						gs_CANComm.fSetRectCtlVoltCurr(GRP_A, gEVBms_1_Info.fBMSRequireVolt, gEVBms_1_Info.fBMSRequireCurr);
					}
					else if (gEvChargeInfo.u8TestMode[GUN_NO_B] == TRUE) 
					{
						gEVBms_2_Info.fBMSRequireVolt = untemp.ftemp;
						gEVBms_2_Info.fBMSRequireCurr = 10;
						gs_CANComm.fSetRectCtlVoltCurr(GRP_B, gEVBms_2_Info.fBMSRequireVolt, gEVBms_2_Info.fBMSRequireCurr);
					}
				}
				else if(gEvChargeInfo.u8_AutoTestStep == 24)//第四步，10秒后记录下电压B实测值，用模块上报电压替代	
				{
					if (gEvChargeInfo.u8TestMode[GUN_NO_A] == TRUE) 
					{						
						gEvChargeInfo.fBattSet_B_Volt = gs_CANComm.GrpData[GRP_A].fOutVolt;
						gEvChargeInfo.u8Batt_1VoltSet_B_Flag = TRUE;					
					}
					else if (gEvChargeInfo.u8TestMode[GUN_NO_B] == TRUE) 
					{
						gEvChargeInfo.fBattSet_B_Volt = gs_CANComm.GrpData[GRP_B].fOutVolt;
						gEvChargeInfo.u8Batt_2VoltSet_B_Flag = TRUE;
					}
				}
				else if(gEvChargeInfo.u8_AutoTestStep == 27)	  //结束
				{
					if (gEvChargeInfo.u8TestMode[GUN_NO_A] == TRUE)
					{
						gEvChargeInfo.u8TestMode[GUN_NO_A] = FALSE;
						gs_CANComm.fSetRectCtlStatus(GRP_A, RECT_OFF);
						__A_DC_MCCB_OFF();
					}
					if (gEvChargeInfo.u8TestMode[GUN_NO_B] == TRUE)
					{									
						gEvChargeInfo.u8TestMode[GUN_NO_B] = FALSE;
						gs_CANComm.fSetRectCtlStatus(GRP_B, RECT_OFF);
						__B_DC_MCCB_OFF();
					}

					gEvChargeInfo.u8_AutoTestStep = 0;
				}

			}  // end:  if (su8Sec != tmNow.tm_sec)
		}  // end: else if(gEvChargeInfo.u8_AutoTestStep > 1)
	}  // end: if(gEvChargeInfo.u8_AutoTestStep > 0)
	else
	{
		su8Sec = 0xff;
		su8SecDelay = 0;
	}

	
}

